{"version":3,"sources":["index.js","shape.js","arc.js","ellipseArc.js","sector.js","ellipseSector.js","util.js","polyline.js","polycurve.js","wave.js","ring.js","polygon.js","triangle.js","rect.js","star.js","ellipse.js","circle.js","../package.json"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA,ACHA;ADIA,ACHA;ADIA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,AFMA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,ACHA,AHSA,ACHA;ACFA,ACHA,AHSA,AIZA,AHSA;ACFA,ACHA,AHSA,AIZA,AHSA;ACFA,ACHA,AHSA,AIZA,AHSA;ACFA,ACHA,AENA,ALeA,AIZA,AHSA;ACFA,ACHA,AENA,ALeA,AIZA,AHSA;ACFA,ACHA,AENA,ALeA,AIZA,AHSA;ACFA,ACHA,AENA,ALeA,AIZA,AHSA,AKfA;AJaA,ACHA,AENA,ALeA,AIZA,AHSA,AKfA;AJaA,ACHA,AENA,ALeA,AIZA,AHSA,AKfA;AJaA,ACHA,AENA,ALeA,AOrBA,AHSA,AHSA,AKfA;AJaA,ACHA,AENA,ALeA,AOrBA,AHSA,AHSA,AKfA;AJaA,ACHA,AENA,ALeA,AOrBA,AHSA,AHSA,AKfA;AJaA,ACHA,AENA,ALeA,AQxBA,ADGA,AHSA,AHSA,AKfA;AJaA,ACHA,AENA,ALeA,AQxBA,ADGA,AHSA,AHSA,AKfA;AJaA,ACHA,AENA,ALeA,AQxBA,ADGA,AHSA,AHSA,AKfA;AJaA,ACHA,AENA,ALeA,AQxBA,ADGA,AHSA,AHSA,AKfA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,ADGA,AHSA,AHSA,AKfA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,ADGA,AHSA,AHSA,AKfA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,ADGA,AGTA,ANkBA,AHSA,AKfA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,ADGA,AGTA,ANkBA,AHSA,AKfA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,ADGA,AGTA,ANkBA,AHSA,AKfA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,AGTA,AJYA,AGTA,ANkBA,AHSA,AKfA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,AGTA,AJYA,AGTA,ANkBA,AHSA,AKfA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,AGTA,AJYA,AGTA,ANkBA,AHSA,AKfA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,AGTA,AJYA,AGTA,ANkBA,AHSA,AWjCA,ANkBA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,AGTA,AJYA,AGTA,ANkBA,AHSA,AWjCA,ANkBA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,AGTA,AJYA,AGTA,ANkBA,AHSA,AWjCA,ANkBA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AWjCA,ANkBA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AWjCA,ANkBA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AWjCA,ANkBA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;APsBA,ACHA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;APsBA,AavCA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;APsBA,AavCA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;APsBA,AavCA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;APsBA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;APsBA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;APsBA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,ANkBA,AHSA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,ADGA,AZoCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,AFMA,ANkBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,Af6CA,Ac1CA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AQvBA,ADGA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AOpBA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AOpBA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AOpBA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AOpBA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AOpBA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AOpBA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AOpBA,AbuCA,AENA,ALeA,AQxBA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AOpBA,AbuCA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AT2BA,AavCA,ARwBA,AGTA;AOpBA,AbuCA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;AOpBA,AbuCA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ARwBA,AGTA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,AIZA,ALeA;ANmBA,AENA,AGTA,AGTA,AJYA,AMlBA,AHSA,ADGA;ANmBA,AENA,AGTA,AGTA,AJYA,AGTA,ADGA;ANmBA,AENA,AGTA,AGTA,AJYA,AGTA,ADGA;ANmBA,AENA,AGTA,AGTA,AJYA,AGTA,ADGA;ANmBA,AENA,AGTA,AGTA,AJYA,AGTA,ADGA;ANmBA,AENA,AGTA,AGTA,AJYA,AGTA,ADGA;ANmBA,AENA,AGTA,AGTA,AJYA,AGTA,ADGA;ANmBA,AENA,AGTA,AGTA,AJYA,AGTA,ADGA;ANmBA,AENA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AGTA,AGTA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,ADGA,ADGA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AMlBA,AFMA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AJaA,AIZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.install = install;\nObject.defineProperty(exports, \"Shape\", {\n  enumerable: true,\n  get: function get() {\n    return _shape.default;\n  }\n});\nObject.defineProperty(exports, \"Arc\", {\n  enumerable: true,\n  get: function get() {\n    return _arc.default;\n  }\n});\nObject.defineProperty(exports, \"Polyline\", {\n  enumerable: true,\n  get: function get() {\n    return _polyline.default;\n  }\n});\nObject.defineProperty(exports, \"Polycurve\", {\n  enumerable: true,\n  get: function get() {\n    return _polycurve.default;\n  }\n});\nObject.defineProperty(exports, \"Wave\", {\n  enumerable: true,\n  get: function get() {\n    return _wave.default;\n  }\n});\nObject.defineProperty(exports, \"Ring\", {\n  enumerable: true,\n  get: function get() {\n    return _ring.default;\n  }\n});\nObject.defineProperty(exports, \"Polygon\", {\n  enumerable: true,\n  get: function get() {\n    return _polygon.default;\n  }\n});\nObject.defineProperty(exports, \"Triangle\", {\n  enumerable: true,\n  get: function get() {\n    return _triangle.default;\n  }\n});\nObject.defineProperty(exports, \"Rect\", {\n  enumerable: true,\n  get: function get() {\n    return _rect.default;\n  }\n});\nObject.defineProperty(exports, \"Star\", {\n  enumerable: true,\n  get: function get() {\n    return _star.default;\n  }\n});\nObject.defineProperty(exports, \"EllipseSector\", {\n  enumerable: true,\n  get: function get() {\n    return _ellipseSector.default;\n  }\n});\nObject.defineProperty(exports, \"EllipseArc\", {\n  enumerable: true,\n  get: function get() {\n    return _ellipseArc.default;\n  }\n});\nObject.defineProperty(exports, \"Sector\", {\n  enumerable: true,\n  get: function get() {\n    return _sector.default;\n  }\n});\nObject.defineProperty(exports, \"Ellipse\", {\n  enumerable: true,\n  get: function get() {\n    return _ellipse.default;\n  }\n});\nObject.defineProperty(exports, \"Circle\", {\n  enumerable: true,\n  get: function get() {\n    return _circle.default;\n  }\n});\nexports.default = exports.version = exports.Shapes = void 0;\n\nvar _shape = _interopRequireDefault(require(\"./shape\"));\n\nvar _arc = _interopRequireDefault(require(\"./arc\"));\n\nvar _polyline = _interopRequireDefault(require(\"./polyline\"));\n\nvar _polycurve = _interopRequireDefault(require(\"./polycurve\"));\n\nvar _wave = _interopRequireDefault(require(\"./wave\"));\n\nvar _ring = _interopRequireDefault(require(\"./ring\"));\n\nvar _polygon = _interopRequireDefault(require(\"./polygon\"));\n\nvar _triangle = _interopRequireDefault(require(\"./triangle\"));\n\nvar _rect = _interopRequireDefault(require(\"./rect\"));\n\nvar _star = _interopRequireDefault(require(\"./star\"));\n\nvar _ellipseSector = _interopRequireDefault(require(\"./ellipseSector\"));\n\nvar _ellipseArc = _interopRequireDefault(require(\"./ellipseArc\"));\n\nvar _sector = _interopRequireDefault(require(\"./sector\"));\n\nvar _ellipse = _interopRequireDefault(require(\"./ellipse\"));\n\nvar _circle = _interopRequireDefault(require(\"./circle\"));\n\nvar version = require('../package.json').version;\n\nexports.version = version;\nvar Shapes = {\n  version: version,\n  install: install,\n  Shape: _shape.default,\n  Polyline: _polyline.default,\n  Polycurve: _polycurve.default,\n  Wave: _wave.default,\n  Polygon: _polygon.default,\n  Triangle: _triangle.default,\n  Rect: _rect.default,\n  Star: _star.default,\n  Arc: _arc.default,\n  Sector: _sector.default,\n  Ellipse: _ellipse.default,\n  EllipseSector: _ellipseSector.default,\n  EllipseArc: _ellipseArc.default,\n  Circle: _circle.default,\n  Ring: _ring.default\n};\nexports.Shapes = Shapes;\n\nfunction install(spritejs) {\n  return Object.keys(Shapes).reduce(function (pkg, key) {\n    if (key === 'version' || key === 'install') {\n      return pkg;\n    }\n\n    return Object.assign(pkg, spritejs.use(Shapes[key], null, false));\n  }, {});\n} // auto use\n// if (typeof window !== 'undefined' && window.spritejs) {\n//   window.spritejs.use(Shapes);\n// }\n\n\nvar _default = Shapes;\nexports.default = _default;","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return (0, _toArray2.default)(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return (0, _typeof2.default)(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if ((0, _typeof2.default)(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if ((0, _typeof2.default)(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\n// import { draggable, droppable } from 'sprite-draggable';\nfunction install(_ref) {\n  var BaseSprite = _ref.BaseSprite,\n      utils = _ref.utils;\n  var attr = utils.attr,\n      parseColorString = utils.parseColorString;\n\n  var ShapeAttr = _decorate(null, function (_initialize, _BaseSprite$Attr) {\n    var ShapeAttr =\n    /*#__PURE__*/\n    function (_BaseSprite$Attr2) {\n      (0, _inherits2.default)(ShapeAttr, _BaseSprite$Attr2);\n\n      function ShapeAttr(subject) {\n        var _this;\n\n        (0, _classCallCheck2.default)(this, ShapeAttr);\n        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ShapeAttr).call(this, subject));\n\n        _initialize((0, _assertThisInitialized2.default)(_this));\n\n        _this.setDefault({\n          color: 'transparent',\n          fillColor: 'transparent',\n          lineWidth: 0,\n          lineCap: 'butt',\n          lineJoin: 'miter',\n          lineDash: [0, 0],\n          lineDashOffset: 0,\n          enableCache: false\n        });\n\n        return _this;\n      } // @attr\n      // set draggable(val) {\n      //   this.set('draggable', val);\n      //   draggable(this.subject, val);\n      // }\n      // @attr\n      // set droppable(val) {\n      //   this.set('droppable', val);\n      //   droppable(this.subject, val);\n      // }\n\n\n      return ShapeAttr;\n    }(_BaseSprite$Attr);\n\n    return {\n      F: ShapeAttr,\n      d: [{\n        kind: \"set\",\n        decorators: [attr],\n        key: \"lineWidth\",\n        value: function lineWidth(val) {\n          this.set('lineWidth', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr],\n        key: \"lineCap\",\n        value: function lineCap(val) {\n          this.set('lineCap', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr],\n        key: \"lineJoin\",\n        value: function lineJoin(val) {\n          this.set('lineJoin', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr],\n        key: \"lineDash\",\n        value: function lineDash(val) {\n          this.set('lineDash', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr],\n        key: \"lineDashOffset\",\n        value: function lineDashOffset(val) {\n          this.set('lineDashOffset', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr],\n        key: \"fillColor\",\n        value: function fillColor(val) {\n          val = parseColorString(val);\n          this.set('fillColor', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr],\n        key: \"strokeColor\",\n        value: function strokeColor(val) {\n          val = parseColorString(val);\n          this.set('strokeColor', val);\n        }\n      }]\n    };\n  }, BaseSprite.Attr);\n\n  var Shape =\n  /*#__PURE__*/\n  function (_BaseSprite) {\n    (0, _inherits2.default)(Shape, _BaseSprite);\n\n    function Shape() {\n      (0, _classCallCheck2.default)(this, Shape);\n      return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Shape).apply(this, arguments));\n    }\n\n    return Shape;\n  }(BaseSprite);\n\n  (0, _defineProperty2.default)(Shape, \"Attr\", ShapeAttr);\n  return {\n    Shape: Shape\n  };\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _shape = _interopRequireDefault(require(\"./shape\"));\n\nvar _ellipseArc = _interopRequireDefault(require(\"./ellipseArc\"));\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return (0, _toArray2.default)(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return (0, _typeof2.default)(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if ((0, _typeof2.default)(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if ((0, _typeof2.default)(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction install(_ref) {\n  var use = _ref.use,\n      utils = _ref.utils,\n      registerNodeType = _ref.registerNodeType;\n  var attr = utils.attr;\n\n  var _use = use(_ellipseArc.default, null, false),\n      EllipseArc = _use.EllipseArc;\n\n  var reflow = true;\n\n  var ArcAttr = _decorate(null, function (_initialize, _EllipseArc$Attr) {\n    var ArcAttr =\n    /*#__PURE__*/\n    function (_EllipseArc$Attr2) {\n      (0, _inherits2.default)(ArcAttr, _EllipseArc$Attr2);\n\n      function ArcAttr(subject) {\n        var _this;\n\n        (0, _classCallCheck2.default)(this, ArcAttr);\n        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(ArcAttr).call(this, subject));\n\n        _initialize((0, _assertThisInitialized2.default)(_this));\n\n        _this.setDefault({\n          radius: 10\n        });\n\n        return _this;\n      } // 圆弧起始点\n\n\n      return ArcAttr;\n    }(_EllipseArc$Attr);\n\n    return {\n      F: ArcAttr,\n      d: [{\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"radius\",\n        value: function radius(val) {\n          this.set('radius', val);\n        }\n      }]\n    };\n  }, EllipseArc.Attr);\n\n  var Arc =\n  /*#__PURE__*/\n  function (_EllipseArc) {\n    (0, _inherits2.default)(Arc, _EllipseArc);\n\n    function Arc() {\n      (0, _classCallCheck2.default)(this, Arc);\n      return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Arc).apply(this, arguments));\n    }\n\n    (0, _createClass2.default)(Arc, [{\n      key: \"radiuses\",\n      get: function get() {\n        var radius = this.attr('radius');\n        return [radius, radius];\n      }\n    }]);\n    return Arc;\n  }(EllipseArc);\n\n  (0, _defineProperty2.default)(Arc, \"Attr\", ArcAttr);\n  registerNodeType('arc', Arc, false);\n  return {\n    Arc: Arc\n  };\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf3 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _shape = _interopRequireDefault(require(\"./shape\"));\n\nvar _sector = _interopRequireDefault(require(\"./sector\"));\n\nvar _util = require(\"./util\");\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return (0, _toArray2.default)(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return (0, _typeof2.default)(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if ((0, _typeof2.default)(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if ((0, _typeof2.default)(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction install(_ref) {\n  var use = _ref.use,\n      utils = _ref.utils,\n      registerNodeType = _ref.registerNodeType;\n  var findColor = utils.findColor,\n      flow = utils.flow;\n\n  var _use = use(_shape.default, null, false),\n      Shape = _use.Shape;\n\n  var _use2 = use(_sector.default, null, false),\n      Sector = _use2.Sector;\n\n  var EllipseArcAttr =\n  /*#__PURE__*/\n  function (_Sector$Attr) {\n    (0, _inherits2.default)(EllipseArcAttr, _Sector$Attr);\n\n    /* eslint-disable no-useless-constructor */\n    function EllipseArcAttr(subject) {\n      (0, _classCallCheck2.default)(this, EllipseArcAttr);\n      return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf3.default)(EllipseArcAttr).call(this, subject));\n    }\n\n    return EllipseArcAttr;\n  }(Sector.Attr);\n\n  var EllipseArc = _decorate(null, function (_initialize, _Shape) {\n    var EllipseArc =\n    /*#__PURE__*/\n    function (_Shape2) {\n      (0, _inherits2.default)(EllipseArc, _Shape2);\n\n      function EllipseArc() {\n        var _getPrototypeOf2;\n\n        var _this;\n\n        (0, _classCallCheck2.default)(this, EllipseArc);\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(EllipseArc)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n        _initialize((0, _assertThisInitialized2.default)(_this));\n\n        return _this;\n      }\n\n      return EllipseArc;\n    }(_Shape);\n\n    return {\n      F: EllipseArc,\n      d: [{\n        kind: \"field\",\n        static: true,\n        key: \"Attr\",\n        value: function value() {\n          return EllipseArcAttr;\n        }\n      }, {\n        kind: \"get\",\n        key: \"isVirtual\",\n        value: function isVirtual() {\n          return false;\n        }\n      }, {\n        kind: \"get\",\n        decorators: [flow],\n        key: \"lineBoundings\",\n        value: function lineBoundings() {\n          var _this$radiuses = (0, _slicedToArray2.default)(this.radiuses, 2),\n              rx = _this$radiuses[0],\n              ry = _this$radiuses[1];\n\n          return [0, 0, 2 * rx, 2 * ry];\n        }\n      }, {\n        kind: \"get\",\n        decorators: [flow],\n        key: \"contentSize\",\n        value: function contentSize() {\n          var bounds = this.lineBoundings;\n\n          var _ref2 = (0, _toConsumableArray2.default)(this.attrSize),\n              width = _ref2[0],\n              height = _ref2[1];\n\n          width = bounds[2] - Math.min(0, bounds[0]);\n          height = bounds[3] - Math.min(0, bounds[1]);\n          return [width, height].map(Math.ceil);\n        }\n      }, {\n        kind: \"get\",\n        key: \"radiuses\",\n        value: function radiuses() {\n          return [this.attr('radiusX'), this.attr('radiusY')];\n        }\n      }, {\n        kind: \"get\",\n        key: \"center\",\n        value: function center() {\n          var _this$radiuses2 = (0, _slicedToArray2.default)(this.radiuses, 2),\n              rx = _this$radiuses2[0],\n              ry = _this$radiuses2[1];\n\n          return [rx, ry];\n        }\n      }, {\n        kind: \"method\",\n        key: \"pointCollision\",\n        value: function pointCollision(evt) {\n          if ((0, _get2.default)((0, _getPrototypeOf3.default)(EllipseArc.prototype), \"pointCollision\", this).call(this, evt)) {\n            var offsetX = evt.offsetX,\n                offsetY = evt.offsetY;\n\n            var _this$attr = this.attr('anchor'),\n                _this$attr2 = (0, _slicedToArray2.default)(_this$attr, 2),\n                anchorX = _this$attr2[0],\n                anchorY = _this$attr2[1];\n\n            var _this$contentSize = (0, _slicedToArray2.default)(this.contentSize, 2),\n                width = _this$contentSize[0],\n                height = _this$contentSize[1];\n\n            offsetX += width * anchorX;\n            offsetY += height * anchorY;\n            var lw = this.attr('lineWidth');\n            var rx = this.radiuses[0] - lw / 2;\n            var ry = this.radiuses[1] - lw / 2;\n\n            var _this$center = (0, _slicedToArray2.default)(this.center, 2),\n                cx = _this$center[0],\n                cy = _this$center[1];\n\n            var dx = offsetX - cx;\n            var dy = offsetY - cy;\n\n            if (Math.abs(Math.pow(dx, 2) / Math.pow(rx, 2) + Math.pow(dy, 2) / Math.pow(ry, 2) - 1) <= 2 * lw / (rx + ry)) {\n              var PI2 = 2 * Math.PI;\n              var startAngle = this.attr('startAngle') % (2 * PI2);\n              var endAngle = this.attr('endAngle') % (2 * PI2);\n              if (startAngle < 0) startAngle += PI2;\n              if (endAngle < 0) endAngle += PI2;\n              var angle = (0, _util.angleOf)([dx, dy]);\n\n              if (angle >= startAngle && angle <= endAngle) {\n                return true;\n              }\n            }\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"render\",\n        value: function render(t, drawingContext) {\n          (0, _get2.default)((0, _getPrototypeOf3.default)(EllipseArc.prototype), \"render\", this).call(this, t, drawingContext);\n\n          var _this$radiuses3 = (0, _slicedToArray2.default)(this.radiuses, 2),\n              radiusX = _this$radiuses3[0],\n              radiusY = _this$radiuses3[1];\n\n          var _this$center2 = (0, _slicedToArray2.default)(this.center, 2),\n              cx = _this$center2[0],\n              cy = _this$center2[1];\n\n          var startAngle = this.attr('startAngle');\n          var endAngle = this.attr('endAngle');\n          var anticlockwise = this.attr('anticlockwise');\n          var lw = this.attr('lineWidth');\n          drawingContext.lineCap = this.attr('lineCap');\n          drawingContext.lineJoin = this.attr('lineJoin');\n          drawingContext.lineWidth = lw;\n          drawingContext.strokeStyle = findColor(drawingContext, this, 'color');\n          drawingContext.setLineDash(this.attr('lineDash'));\n          drawingContext.lineDashOffset = this.attr('lineDashOffset');\n          drawingContext.strokeStyle = findColor(drawingContext, this, 'strokeColor');\n          drawingContext.fillStyle = findColor(drawingContext, this, 'fillColor');\n          drawingContext.beginPath();\n\n          if (drawingContext.ellipse) {\n            drawingContext.ellipse(cx, cy, Math.max(0, radiusX - lw / 2), Math.max(0, radiusY - lw / 2), 0, startAngle, endAngle, anticlockwise);\n          } else if (radiusX === radiusY) {\n            drawingContext.arc(cx, cy, Math.max(0, radiusX - lw / 2), startAngle, endAngle, anticlockwise);\n          } else {\n            throw new Error(\"Your browser does'n support canvas ellipse\");\n          }\n\n          drawingContext.fill();\n          drawingContext.stroke();\n          return drawingContext;\n        }\n      }]\n    };\n  }, Shape);\n\n  registerNodeType('ellipsearc', EllipseArc, false);\n  return {\n    EllipseArc: EllipseArc\n  };\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _ellipseSector = _interopRequireDefault(require(\"./ellipseSector\"));\n\nfunction install(_ref) {\n  var use = _ref.use,\n      utils = _ref.utils,\n      registerNodeType = _ref.registerNodeType;\n\n  var _use = use(_ellipseSector.default, null, false),\n      EllipseSector = _use.EllipseSector;\n\n  var Sector =\n  /*#__PURE__*/\n  function (_EllipseSector) {\n    (0, _inherits2.default)(Sector, _EllipseSector);\n\n    function Sector() {\n      (0, _classCallCheck2.default)(this, Sector);\n      return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Sector).apply(this, arguments));\n    }\n\n    (0, _createClass2.default)(Sector, [{\n      key: \"radiuses\",\n      get: function get() {\n        return [this.attr('radius'), this.attr('radius')];\n      }\n    }]);\n    return Sector;\n  }(EllipseSector);\n\n  Sector.defineAttributes({\n    radius: function radius(attr, val) {\n      attr.clearFlow();\n      attr.set('radius', val);\n    }\n  });\n  registerNodeType('sector', Sector, false);\n  return {\n    Sector: Sector\n  };\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf3 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _shape = _interopRequireDefault(require(\"./shape\"));\n\nvar _util = require(\"./util\");\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return (0, _toArray2.default)(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return (0, _typeof2.default)(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if ((0, _typeof2.default)(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if ((0, _typeof2.default)(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction install(_ref) {\n  var use = _ref.use,\n      utils = _ref.utils,\n      registerNodeType = _ref.registerNodeType;\n  var attr = utils.attr,\n      flow = utils.flow,\n      parseColorString = utils.parseColorString,\n      findColor = utils.findColor;\n\n  var _use = use(_shape.default, null, false),\n      Shape = _use.Shape;\n\n  var reflow = true;\n\n  var EllipseSectorAttr = _decorate(null, function (_initialize, _Shape$Attr) {\n    var EllipseSectorAttr =\n    /*#__PURE__*/\n    function (_Shape$Attr2) {\n      (0, _inherits2.default)(EllipseSectorAttr, _Shape$Attr2);\n\n      function EllipseSectorAttr(subject) {\n        var _this;\n\n        (0, _classCallCheck2.default)(this, EllipseSectorAttr);\n        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf3.default)(EllipseSectorAttr).call(this, subject));\n\n        _initialize((0, _assertThisInitialized2.default)(_this));\n\n        _this.setDefault({\n          radiusX: 10,\n          radiusY: 20,\n          startAngle: 0,\n          endAngle: 0,\n          lineWidth: 1,\n          anticlockwise: false\n        });\n\n        return _this;\n      } // 短轴半径\n\n\n      return EllipseSectorAttr;\n    }(_Shape$Attr);\n\n    return {\n      F: EllipseSectorAttr,\n      d: [{\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"radiusX\",\n        value: function radiusX(val) {\n          this.set('radiusX', val);\n        } // 长轴半径\n\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"radiusY\",\n        value: function radiusY(val) {\n          this.set('radiusY', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"startAngle\",\n        value: function startAngle(val) {\n          this.set('startAngle', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"endAngle\",\n        value: function endAngle(val) {\n          this.set('endAngle', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"lineWidth\",\n        value: function lineWidth(val) {\n          this.set('lineWidth', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr],\n        key: \"fillColor\",\n        value: function fillColor(val) {\n          val = parseColorString(val);\n          this.set('fillColor', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr],\n        key: \"anticlockwise\",\n        value: function anticlockwise(val) {\n          this.set('anticlockwise', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"center\",\n        value: function center(val) {\n          this.set('center', val);\n        }\n      }]\n    };\n  }, Shape.Attr);\n\n  var EllipseSector = _decorate(null, function (_initialize2, _Shape) {\n    var EllipseSector =\n    /*#__PURE__*/\n    function (_Shape2) {\n      (0, _inherits2.default)(EllipseSector, _Shape2);\n\n      function EllipseSector() {\n        var _getPrototypeOf2;\n\n        var _this2;\n\n        (0, _classCallCheck2.default)(this, EllipseSector);\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this2 = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(EllipseSector)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n        _initialize2((0, _assertThisInitialized2.default)(_this2));\n\n        return _this2;\n      }\n\n      return EllipseSector;\n    }(_Shape);\n\n    return {\n      F: EllipseSector,\n      d: [{\n        kind: \"field\",\n        static: true,\n        key: \"Attr\",\n        value: function value() {\n          return EllipseSectorAttr;\n        }\n      }, {\n        kind: \"get\",\n        key: \"radiuses\",\n        value: function radiuses() {\n          return [this.attr('radiusX'), this.attr('radiusY')];\n        }\n      }, {\n        kind: \"get\",\n        key: \"startAngle\",\n        value: function startAngle() {\n          return this.attr('startAngle');\n        }\n      }, {\n        kind: \"get\",\n        key: \"endAngle\",\n        value: function endAngle() {\n          return this.attr('endAngle');\n        }\n      }, {\n        kind: \"get\",\n        key: \"center\",\n        value: function center() {\n          var lw = this.attr('lineWidth');\n          return this.radiuses.map(function (v) {\n            return v;\n          });\n        }\n      }, {\n        kind: \"get\",\n        key: \"lineBoundings\",\n        value: function lineBoundings() {\n          return [0, 0, 2 * this.radiuses[0], 2 * this.radiuses[1]];\n        }\n      }, {\n        kind: \"get\",\n        decorators: [flow],\n        key: \"contentSize\",\n        value: function contentSize() {\n          var bounds = this.lineBoundings;\n          var lw = this.attr('lineWidth');\n\n          var _ref2 = (0, _toConsumableArray2.default)(this.attrSize),\n              width = _ref2[0],\n              height = _ref2[1];\n\n          width = bounds[2] - Math.min(0, bounds[0]);\n          height = bounds[3] - Math.min(0, bounds[1]);\n          return [width, height].map(Math.ceil);\n        } // @flow\n        // get originalRect() {\n        //   const lineBoundings = this.lineBoundings;\n        //   const [x, y, w, h] = super.originalRect;\n        //   const rect = [x - lineBoundings[0] / 2, y - lineBoundings[1] / 2, w, h];\n        //   return rect;\n        // }\n\n      }, {\n        kind: \"method\",\n        key: \"pointCollision\",\n        value: function pointCollision(evt) {\n          if ((0, _get2.default)((0, _getPrototypeOf3.default)(EllipseSector.prototype), \"pointCollision\", this).call(this, evt)) {\n            var offsetX = evt.offsetX,\n                offsetY = evt.offsetY; // FIXME: 如果事件是改变半径大小，会导致contentSize变化，如何避免？\n\n            var _this$attr = this.attr('anchor'),\n                _this$attr2 = (0, _slicedToArray2.default)(_this$attr, 2),\n                anchorX = _this$attr2[0],\n                anchorY = _this$attr2[1];\n\n            var _this$contentSize = (0, _slicedToArray2.default)(this.contentSize, 2),\n                width = _this$contentSize[0],\n                height = _this$contentSize[1];\n\n            offsetX += width * anchorX;\n            offsetY += height * anchorY;\n\n            var _this$center = (0, _slicedToArray2.default)(this.center, 2),\n                x = _this$center[0],\n                y = _this$center[1];\n\n            var _this$radiuses = (0, _slicedToArray2.default)(this.radiuses, 2),\n                rx = _this$radiuses[0],\n                ry = _this$radiuses[1];\n\n            var dx = offsetX - x;\n            var dy = offsetY - y;\n\n            if (Math.pow(dx, 2) / Math.pow(rx, 2) + Math.pow(dy, 2) / Math.pow(ry, 2) <= 1.0) {\n              var PI2 = 2 * Math.PI;\n              var startAngle = this.startAngle;\n              var endAngle = this.endAngle;\n\n              if (endAngle - startAngle >= PI2) {\n                startAngle = 0;\n                endAngle = PI2;\n              } else {\n                if (startAngle >= 0 && endAngle >= 0) {\n                  var offsetAngle = endAngle - startAngle;\n                  startAngle %= PI2;\n                  endAngle = startAngle + offsetAngle;\n                } else {\n                  var nTPositive = function nTPositive(angle) {\n                    // 使其落入 [0, PI2]区间\n                    var PI2 = 2 * Math.PI;\n                    var isNegative = angle < 0;\n                    var T = isNegative ? -Math.floor(angle / PI2) : Math.ceil(angle / PI2);\n                    return (angle + T * PI2) % PI2;\n                  };\n\n                  endAngle = nTPositive(endAngle) + (startAngle <= 0 && startAngle >= endAngle ? PI2 : endAngle > 0 ? PI2 : 0);\n                  startAngle = nTPositive(startAngle);\n                }\n              }\n\n              var angle = (0, _util.angleOf)([dx, dy]);\n\n              if (endAngle > PI2) {\n                var m = endAngle - PI2;\n\n                if (0 <= angle && angle <= m) {\n                  angle += PI2;\n                }\n              }\n\n              return angle >= startAngle && angle <= endAngle;\n            } // TODO: 处理 lineCap?\n\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"render\",\n        value: function render(t, ctx) {\n          (0, _get2.default)((0, _getPrototypeOf3.default)(EllipseSector.prototype), \"render\", this).call(this, t, ctx);\n\n          var _this$center2 = (0, _slicedToArray2.default)(this.center, 2),\n              x = _this$center2[0],\n              y = _this$center2[1];\n\n          var _this$radiuses2 = (0, _slicedToArray2.default)(this.radiuses, 2),\n              rx = _this$radiuses2[0],\n              ry = _this$radiuses2[1];\n\n          var startAngle = this.startAngle;\n          var endAngle = this.endAngle;\n          var lw = this.attr('lineWidth');\n          ctx.miterLimit = 3;\n          ctx.miterLimit = 3;\n          ctx.lineCap = this.attr('lineCap');\n          ctx.lineJoin = this.attr('lineJoin');\n          ctx.lineWidth = lw;\n          ctx.strokeStyle = findColor(ctx, this, 'strokeColor');\n          ctx.setLineDash(this.attr('lineDash'));\n          ctx.lineDashOffset = this.attr('lineDashOffset');\n          ctx.strokeStyle = findColor(ctx, this, 'strokeColor');\n          ctx.fillStyle = findColor(ctx, this, 'fillColor');\n          ctx.beginPath();\n\n          if (this.endAngle - this.startAngle < Math.PI * 2) {\n            ctx.moveTo(x, y);\n          }\n\n          if (ctx.ellipse) {\n            ctx.ellipse(x, y, Math.max(0, rx - lw / 2), Math.max(0, ry - lw / 2), 0, startAngle, endAngle, this.attr('anticlockwise'));\n            ctx.closePath();\n          } else if (rx === ry) {\n            ctx.arc(x, y, Math.max(0, rx - lw / 2), startAngle, endAngle, this.attr('anticlockwise'));\n            ctx.closePath();\n          } else {\n            throw new Error(\"Your browser does'n support canvas ellipse\");\n          }\n\n          ctx.fill();\n          ctx.stroke();\n          return ctx;\n        }\n      }]\n    };\n  }, Shape);\n\n  registerNodeType('ellipsesector', EllipseSector, false);\n  return {\n    EllipseSector: EllipseSector\n  };\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.makeSmoothCurveLine = makeSmoothCurveLine;\nexports.drawSmoothCurveLine = drawSmoothCurveLine;\nexports.angleOf = angleOf;\nexports.pointsEqual = pointsEqual;\nexports.round = exports.sin = exports.cos = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar cos = function cos(angle) {\n  return Number(Math.cos(angle).toFixed(15));\n};\n\nexports.cos = cos;\n\nvar sin = function sin(angle) {\n  return Number(Math.sin(angle).toFixed(15));\n};\n\nexports.sin = sin;\n\nvar round = function round(v) {\n  return Math.round(v);\n};\n/**\n * 使用 贝塞尔曲线 模拟绘制平滑曲线\n * @param {*} points 绘制点\n */\n\n\nexports.round = round;\n\nfunction makeSmoothCurveLine(points, smoothStart) {\n  /**\n   * 获取 模拟贝塞尔曲线关键控制点\n   * @param {*} i\n   * @param {*} a\n   * @param {*} b\n   */\n  function getCtrlPoint(i) {\n    var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;\n    var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n    var x0;\n    var y0;\n    var x1;\n    var y1;\n\n    if (points[i].x === points[i + 1].x || points[i].y === points[i + 1].y) {\n      a = 0;\n      b = 0;\n    }\n\n    if (i < 1) {\n      x0 = points[0].x + (points[1].x - points[0].x) * a;\n      y0 = points[0].y + (points[1].y - points[0].y) * a;\n    } else {\n      x0 = points[i].x + (points[i + 1].x - points[i - 1].x) * a;\n      y0 = points[i].y + (points[i + 1].y - points[i - 1].y) * a;\n    }\n\n    if (i > points.length - 3) {\n      var last = points.length - 1;\n      x1 = points[last].x - (points[last].x - points[last - 1].x) * b;\n      y1 = points[last].y - (points[last].y - points[last - 1].y) * b;\n    } else {\n      x1 = points[i + 1].x - (points[i + 2].x - points[i].x) * b;\n      y1 = points[i + 1].y - (points[i + 2].y - points[i].y) * b;\n    }\n\n    return [{\n      x: x0,\n      y: y0\n    }, {\n      x: x1,\n      y: y1\n    }];\n  }\n\n  points = points.map(function (_ref) {\n    var _ref2 = (0, _slicedToArray2.default)(_ref, 2),\n        x = _ref2[0],\n        y = _ref2[1];\n\n    return {\n      x: x,\n      y: y\n    };\n  });\n  var d = '';\n  points.forEach(function (point, i) {\n    if (i === 0 && smoothStart === 0) {\n      // 从第0个点开始绘制曲线\n      d += \"M\".concat(point.x, \" \").concat(point.y);\n    } else if (i === 0 && smoothStart !== 0) {\n      // 不是从第一个开始曲线\n      d += \"L\".concat(point.x, \" \").concat(point.y);\n    } else {\n      var _getCtrlPoint = getCtrlPoint(i - 1),\n          _getCtrlPoint2 = (0, _slicedToArray2.default)(_getCtrlPoint, 2),\n          A = _getCtrlPoint2[0],\n          B = _getCtrlPoint2[1];\n\n      d += \"C\".concat([A.x, A.y, B.x, B.y, point.x, point.y].join(' '));\n    }\n  });\n  return d;\n}\n/**\n * 使用 贝塞尔曲线 模拟绘制平滑曲线\n * @param {*} ctx 绘制上下文,如:Context2D\n * @param {*} points 绘制点\n */\n\n\nfunction drawSmoothCurveLine(ctx, points, smoothStart) {\n  /**\n   * 获取 模拟贝塞尔曲线关键控制点\n   * @param {*} i\n   * @param {*} a\n   * @param {*} b\n   */\n  function getCtrlPoint(i) {\n    var a = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;\n    var b = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;\n    var x0;\n    var y0;\n    var x1;\n    var y1;\n\n    if (points[i].x === points[i + 1].x || points[i].y === points[i + 1].y) {\n      a = 0;\n      b = 0;\n    }\n\n    if (i < 1) {\n      x0 = points[0].x + (points[1].x - points[0].x) * a;\n      y0 = points[0].y + (points[1].y - points[0].y) * a;\n    } else {\n      x0 = points[i].x + (points[i + 1].x - points[i - 1].x) * a;\n      y0 = points[i].y + (points[i + 1].y - points[i - 1].y) * a;\n    }\n\n    if (i > points.length - 3) {\n      var last = points.length - 1;\n      x1 = points[last].x - (points[last].x - points[last - 1].x) * b;\n      y1 = points[last].y - (points[last].y - points[last - 1].y) * b;\n    } else {\n      x1 = points[i + 1].x - (points[i + 2].x - points[i].x) * b;\n      y1 = points[i + 1].y - (points[i + 2].y - points[i].y) * b;\n    }\n\n    return [{\n      x: x0,\n      y: y0\n    }, {\n      x: x1,\n      y: y1\n    }];\n  }\n\n  points = points.map(function (_ref3) {\n    var _ref4 = (0, _slicedToArray2.default)(_ref3, 2),\n        x = _ref4[0],\n        y = _ref4[1];\n\n    return {\n      x: x,\n      y: y\n    };\n  });\n  points.forEach(function (point, i) {\n    if (i === 0 && smoothStart === 0) {\n      // 从第0个点开始绘制曲线\n      ctx.moveTo(point.x, point.y);\n    } else if (i === 0 && smoothStart !== 0) {\n      // 不是从第一个开始曲线\n      ctx.lineTo(point.x, point.y);\n    } else {\n      var _getCtrlPoint3 = getCtrlPoint(i - 1),\n          _getCtrlPoint4 = (0, _slicedToArray2.default)(_getCtrlPoint3, 2),\n          A = _getCtrlPoint4[0],\n          B = _getCtrlPoint4[1];\n\n      ctx.bezierCurveTo(A.x, A.y, B.x, B.y, point.x, point.y);\n    }\n  });\n}\n\nfunction angleOf(v1) {\n  var v2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [1, 0];\n  var ang = Math.atan2(v1[1], v1[0]) - Math.atan2(v2[1], v2[0]);\n  if (ang < 0.0) ang += 2.0 * Math.PI;\n  return ang;\n}\n\nfunction pointsEqual(p1, p2) {\n  if (p1.length !== p2.length) return false;\n\n  for (var i = 0; i < p1.length; i++) {\n    if (p1[i][0] !== p2[i][0] || p1[i][1] !== p2[i][1]) return false;\n  }\n\n  return true;\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _shape = _interopRequireDefault(require(\"./shape\"));\n\nvar _svgPathToCanvas = _interopRequireDefault(require(\"svg-path-to-canvas\"));\n\nvar _util = require(\"./util\");\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return (0, _toArray2.default)(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return (0, _typeof2.default)(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if ((0, _typeof2.default)(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if ((0, _typeof2.default)(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction install(_ref) {\n  var use = _ref.use,\n      utils = _ref.utils,\n      registerNodeType = _ref.registerNodeType;\n  var attr = utils.attr,\n      findColor = utils.findColor;\n\n  var _use = use(_shape.default, null, false),\n      Shape = _use.Shape;\n\n  var reflow = true;\n\n  var PolylineAttr = _decorate(null, function (_initialize, _Shape$Attr) {\n    var PolylineAttr =\n    /*#__PURE__*/\n    function (_Shape$Attr2) {\n      (0, _inherits2.default)(PolylineAttr, _Shape$Attr2);\n\n      function PolylineAttr(subject) {\n        var _this;\n\n        (0, _classCallCheck2.default)(this, PolylineAttr);\n        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(PolylineAttr).call(this, subject));\n\n        _initialize((0, _assertThisInitialized2.default)(_this));\n\n        _this.setDefault({\n          points: null,\n          close: false,\n          smooth: false,\n          tolerance: 6\n        });\n\n        return _this;\n      }\n\n      return PolylineAttr;\n    }(_Shape$Attr);\n\n    return {\n      F: PolylineAttr,\n      d: [{\n        kind: \"set\",\n        decorators: [attr],\n        key: \"tolerance\",\n        value: function tolerance(val) {\n          this.set('tolerance', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"points\",\n        value: function points(val) {\n          this.set('points', val);\n          this.subject.path = null;\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"smooth\",\n        value: function smooth(val) {\n          this.set('smooth', val);\n          this.subject.path = null;\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr],\n        key: \"close\",\n        value: function close(val) {\n          this.set('close', val);\n          this.subject.path = null;\n        }\n      }]\n    };\n  }, Shape.Attr);\n\n  var Polyline =\n  /*#__PURE__*/\n  function (_Shape) {\n    (0, _inherits2.default)(Polyline, _Shape);\n\n    function Polyline() {\n      (0, _classCallCheck2.default)(this, Polyline);\n      return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Polyline).apply(this, arguments));\n    }\n\n    (0, _createClass2.default)(Polyline, [{\n      key: \"pointCollision\",\n      value: function pointCollision(evt) {\n        (0, _get2.default)((0, _getPrototypeOf2.default)(Polyline.prototype), \"pointCollision\", this).call(this, evt);\n        var offsetX = evt.offsetX,\n            offsetY = evt.offsetY;\n        var cacheLineWidth = this.context.lineWidth; // 获取当前画布的lineWidth宽度\n\n        var tolerance = this.attr('tolerance'); // 线条点击的容差像素值，默认6px\n\n        var res = false;\n        var path = this.path;\n\n        if (path) {\n          var lineWidth = this.attr('lineWidth') + tolerance,\n              lineCap = this.attr('lineCap'),\n              lineJoin = this.attr('lineJoin');\n\n          if (this.attr('close')) {\n            res = path.isPointInPath(offsetX, offsetY);\n          }\n\n          res |= path.isPointInStroke(offsetX, offsetY, {\n            lineWidth: lineWidth,\n            lineCap: lineCap,\n            lineJoin: lineJoin\n          });\n        }\n\n        return res;\n      }\n    }, {\n      key: \"render\",\n      value: function render(t, drawingContext) {\n        (0, _get2.default)((0, _getPrototypeOf2.default)(Polyline.prototype), \"render\", this).call(this, t, drawingContext);\n\n        if (this.points) {\n          var lw = this.attr('lineWidth');\n          drawingContext.fillStyle = this.attr('fillColor');\n          drawingContext.strokeStyle = findColor(drawingContext, this, 'strokeColor');\n          drawingContext.lineJoin = this.attr('lineJoin');\n          drawingContext.lineCap = this.attr('lineCap');\n          drawingContext.lineWidth = lw;\n          drawingContext.setLineDash(this.attr('lineDash'));\n          drawingContext.lineDashOffset = this.attr('lineDashOffset'); // drawingContext.translate(lw / 2, lw / 2);\n\n          if (!this.path || !(0, _util.pointsEqual)(this.path.points, this.points)) {\n            var smooth = this.attr('smooth');\n            var d = '';\n\n            if (smooth) {\n              d += (0, _util.makeSmoothCurveLine)(this.points, 0);\n            } else {\n              this.points.forEach(function (point, i) {\n                if (i === 0) {\n                  d += \"M\".concat(point.join(' '));\n                } else {\n                  d += \"L\".concat(point.join(' '));\n                }\n              });\n            }\n\n            if (this.attr('close')) {\n              d += 'Z';\n            }\n\n            this.path = new _svgPathToCanvas.default(d);\n            this.path.points = (0, _toConsumableArray2.default)(this.points);\n          }\n\n          if (this.path) {\n            this.path.beginPath().to(drawingContext);\n            drawingContext.fill();\n            drawingContext.stroke();\n          }\n        }\n\n        return drawingContext;\n      }\n    }, {\n      key: \"points\",\n      get: function get() {\n        return this.attr('points');\n      }\n    }, {\n      key: \"isVirtual\",\n      get: function get() {\n        return true;\n      }\n    }]);\n    return Polyline;\n  }(Shape);\n\n  (0, _defineProperty2.default)(Polyline, \"Attr\", PolylineAttr);\n  registerNodeType('polyline', Polyline, false);\n  return {\n    Polyline: Polyline\n  };\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _get4 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf3 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _shape = _interopRequireDefault(require(\"./shape\"));\n\nvar _svgPathToCanvas = _interopRequireDefault(require(\"svg-path-to-canvas\"));\n\nvar _util = require(\"./util\");\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return (0, _toArray2.default)(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return (0, _typeof2.default)(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if ((0, _typeof2.default)(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if ((0, _typeof2.default)(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction install(_ref) {\n  var use = _ref.use,\n      utils = _ref.utils,\n      registerNodeType = _ref.registerNodeType;\n  var attr = utils.attr,\n      findColor = utils.findColor,\n      flow = utils.flow;\n\n  var _use = use(_shape.default, null, false),\n      Shape = _use.Shape;\n\n  var reflow = true;\n\n  var PolycurveAttr = _decorate(null, function (_initialize, _Shape$Attr) {\n    var PolycurveAttr =\n    /*#__PURE__*/\n    function (_Shape$Attr2) {\n      (0, _inherits2.default)(PolycurveAttr, _Shape$Attr2);\n\n      function PolycurveAttr(subject) {\n        var _this;\n\n        (0, _classCallCheck2.default)(this, PolycurveAttr);\n        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf3.default)(PolycurveAttr).call(this, subject));\n\n        _initialize((0, _assertThisInitialized2.default)(_this));\n\n        _this.setDefault({\n          points: [],\n          startPoint: null\n        });\n\n        return _this;\n      }\n\n      return PolycurveAttr;\n    }(_Shape$Attr);\n\n    return {\n      F: PolycurveAttr,\n      d: [{\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"points\",\n        value: function points(val) {\n          this.set('points', val);\n          this.subject.path = null;\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"startPoint\",\n        value: function startPoint(val) {\n          this.set('startPoint', val);\n          this.subject.path = null;\n        }\n      }]\n    };\n  }, Shape.Attr);\n\n  var Polycurve = _decorate(null, function (_initialize2, _Shape) {\n    var Polycurve =\n    /*#__PURE__*/\n    function (_Shape2) {\n      (0, _inherits2.default)(Polycurve, _Shape2);\n\n      function Polycurve() {\n        var _getPrototypeOf2;\n\n        var _this2;\n\n        (0, _classCallCheck2.default)(this, Polycurve);\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this2 = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Polycurve)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n        _initialize2((0, _assertThisInitialized2.default)(_this2));\n\n        return _this2;\n      }\n\n      return Polycurve;\n    }(_Shape);\n\n    return {\n      F: Polycurve,\n      d: [{\n        kind: \"field\",\n        static: true,\n        key: \"Attr\",\n        value: function value() {\n          return PolycurveAttr;\n        }\n      }, {\n        kind: \"get\",\n        key: \"points\",\n        value: function points() {\n          return this.attr('points');\n        }\n      }, {\n        kind: \"get\",\n        key: \"lineBoundings\",\n        value: function lineBoundings() {\n          var startPoint = this.attr('startPoint');\n          var points = startPoint && startPoint.length === 2 ? (0, _toConsumableArray2.default)(startPoint) : [];\n          var ps = this.points;\n          ps.forEach(function (p) {\n            return points.push.apply(points, p);\n          });\n          var minX = 0;\n          var maxX = 0;\n          var minY = 0;\n          var maxY = 0;\n          points.forEach(function (point, i) {\n            if (i % 2 === 0) {\n              if (point < minX) {\n                minX = point;\n              } else if (point > maxX) {\n                maxX = point;\n              }\n            } else {\n              if (point < minY) {\n                minY = point;\n              } else if (point > maxY) {\n                maxY = point;\n              }\n            }\n          });\n          return [minX, minY, maxX, maxY];\n        }\n      }, {\n        kind: \"get\",\n        decorators: [flow],\n        key: \"contentSize\",\n        value: function contentSize() {\n          var bounds = this.lineBoundings;\n          var lw = this.attr('lineWidth');\n\n          var _this$attrSize = (0, _slicedToArray2.default)(this.attrSize, 2),\n              width = _this$attrSize[0],\n              height = _this$attrSize[1];\n\n          if (width === '') {\n            width = bounds[2] - Math.min(0, bounds[0]) + lw * 2;\n          }\n\n          if (height === '') {\n            height = bounds[3] - Math.min(0, bounds[1]) + lw * 2;\n          }\n\n          return [width, height].map(Math.ceil);\n        }\n      }, {\n        kind: \"get\",\n        decorators: [flow],\n        key: \"originalRect\",\n        value: function originalRect() {\n          var lineBoundings = this.lineBoundings;\n\n          var _get2 = (0, _get4.default)((0, _getPrototypeOf3.default)(Polycurve.prototype), \"originalRect\", this),\n              _get3 = (0, _slicedToArray2.default)(_get2, 4),\n              x = _get3[0],\n              y = _get3[1],\n              w = _get3[2],\n              h = _get3[3];\n\n          var rect = [x - lineBoundings[0], y - lineBoundings[1], w, h];\n          return rect;\n        }\n      }, {\n        kind: \"get\",\n        key: \"isVirtual\",\n        value: function isVirtual() {\n          return false;\n        }\n      }, {\n        kind: \"method\",\n        key: \"updatePath\",\n        value: function updatePath() {\n          var startPoint = this.attr('startPoint');\n          var points = this.points;\n          var d = '';\n\n          if (startPoint && startPoint.length === 2) {\n            d += \"M\".concat(startPoint.join(' '));\n          }\n\n          points.forEach(function (point) {\n            var _point = (0, _slicedToArray2.default)(point, 6),\n                cp1x = _point[0],\n                cp1y = _point[1],\n                cp2x = _point[2],\n                cp2y = _point[3],\n                x = _point[4],\n                y = _point[5];\n\n            d += \"C\".concat([cp1x, cp1y, cp2x, cp2y, x, y].join(' '));\n          });\n          var svgpath = new _svgPathToCanvas.default(d);\n          this.path = svgpath;\n          this.path.points = (0, _toConsumableArray2.default)(points);\n        }\n      }, {\n        kind: \"method\",\n        key: \"pointCollision\",\n        value: function pointCollision(evt) {\n          if ((0, _get4.default)((0, _getPrototypeOf3.default)(Polycurve.prototype), \"pointCollision\", this).call(this, evt)) {\n            var offsetX = evt.offsetX,\n                offsetY = evt.offsetY;\n\n            var _this$attr = this.attr('anchor'),\n                _this$attr2 = (0, _slicedToArray2.default)(_this$attr, 2),\n                anchorX = _this$attr2[0],\n                anchorY = _this$attr2[1];\n\n            var _this$contentSize = (0, _slicedToArray2.default)(this.contentSize, 2),\n                width = _this$contentSize[0],\n                height = _this$contentSize[1];\n\n            offsetX += width * anchorX;\n            offsetY += height * anchorY;\n            var path = this.path;\n\n            if (path) {\n              var lineWidth = this.attr('lineWidth'),\n                  lineCap = this.attr('lineCap'),\n                  lineJoin = this.attr('lineJoin');\n              return path.isPointInPath(offsetX, offsetY) || path.isPointInStroke(offsetX, offsetY, {\n                lineWidth: lineWidth,\n                lineCap: lineCap,\n                lineJoin: lineJoin\n              });\n            }\n\n            return false;\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"render\",\n        value: function render(t, ctx) {\n          (0, _get4.default)((0, _getPrototypeOf3.default)(Polycurve.prototype), \"render\", this).call(this, t, ctx);\n          var points = this.points;\n          var startPoint = this.attr('startPoint');\n          var lw = this.attr('lineWidth');\n          ctx.lineCap = this.attr('lineCap');\n          ctx.lineJoin = this.attr('lineJoin');\n          ctx.lineWidth = lw;\n          ctx.setLineDash(this.attr('lineDash'));\n          ctx.lineDashOffset = this.attr('lineDashOffset');\n          ctx.fillStyle = this.attr('fillColor');\n          ctx.strokeStyle = findColor(ctx, this, 'strokeColor');\n          if (!this.path || !(0, _util.pointsEqual)(this.path.points, points)) this.updatePath();\n\n          if (this.path) {\n            this.path.beginPath().to(ctx);\n            ctx.fill();\n            ctx.stroke();\n          }\n\n          return ctx;\n        }\n      }]\n    };\n  }, Shape);\n\n  registerNodeType('polycurve', Polycurve, false);\n  return {\n    Polycurve: Polycurve\n  };\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _get4 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf3 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _svgPathToCanvas = _interopRequireDefault(require(\"svg-path-to-canvas\"));\n\nvar _shape = _interopRequireDefault(require(\"./shape\"));\n\nvar _util = require(\"./util\");\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return (0, _toArray2.default)(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return (0, _typeof2.default)(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if ((0, _typeof2.default)(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if ((0, _typeof2.default)(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction install(_ref) {\n  var use = _ref.use,\n      utils = _ref.utils,\n      registerNodeType = _ref.registerNodeType;\n  var attr = utils.attr,\n      findColor = utils.findColor,\n      flow = utils.flow;\n\n  var _use = use(_shape.default, null, false),\n      Shape = _use.Shape;\n\n  var reflow = true;\n\n  var WaveAttr = _decorate(null, function (_initialize, _Shape$Attr) {\n    var WaveAttr =\n    /*#__PURE__*/\n    function (_Shape$Attr2) {\n      (0, _inherits2.default)(WaveAttr, _Shape$Attr2);\n\n      function WaveAttr(subject) {\n        var _this;\n\n        (0, _classCallCheck2.default)(this, WaveAttr);\n        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf3.default)(WaveAttr).call(this, subject));\n\n        _initialize((0, _assertThisInitialized2.default)(_this));\n\n        _this.setDefault({\n          radius: 50,\n          offset: 10,\n          amplitude: 0,\n          // 振幅\n          percent: 0,\n          // 当为数组时将渲染多个 波浪线\n          wavesColor: '#000',\n          // 波浪线颜色\n          shape: '',\n          // 可以使用 svg path，默认圆\n          shapeScale: 1,\n          // 当使用 svg path 时可能需要进行适当比例缩放\n          shapeColor: '#000',\n          // svgpath 边框颜色\n          shapeFillColor: 'transparent',\n          // svgpath 背景颜色\n          showOutline: true,\n          // 用于控制是否显示外圈圆环，当 shape 为 svg path 将强制不显示\n          outlineColor: '#000',\n          // 外圆环颜色\n          speed: 0 // 用于控制移动速度，主要是提供一个可以修改的属性，配合 spritejs 动画用\n\n        });\n\n        return _this;\n      }\n\n      return WaveAttr;\n    }(_Shape$Attr);\n\n    return {\n      F: WaveAttr,\n      d: [{\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"radius\",\n        value: function radius(val) {\n          this.set('radius', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"offset\",\n        value: function offset(val) {\n          this.set('offset', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"amplitude\",\n        value: function amplitude(val) {\n          this.set('amplitude', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"speed\",\n        value: function speed(val) {\n          this.set('speed', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"percent\",\n        value: function percent(val) {\n          this.set('percent', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"wavesColor\",\n        value: function wavesColor(val) {\n          this.set('wavesColor', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"shape\",\n        value: function shape(val) {\n          this.set('shape', val);\n        }\n      }]\n    };\n  }, Shape.Attr);\n\n  var Wave = _decorate(null, function (_initialize2, _Shape) {\n    var Wave =\n    /*#__PURE__*/\n    function (_Shape2) {\n      (0, _inherits2.default)(Wave, _Shape2);\n\n      function Wave() {\n        var _getPrototypeOf2;\n\n        var _this2;\n\n        (0, _classCallCheck2.default)(this, Wave);\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this2 = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Wave)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n        _initialize2((0, _assertThisInitialized2.default)(_this2));\n\n        return _this2;\n      }\n\n      return Wave;\n    }(_Shape);\n\n    return {\n      F: Wave,\n      d: [{\n        kind: \"field\",\n        static: true,\n        key: \"Attr\",\n        value: function value() {\n          return WaveAttr;\n        }\n      }, {\n        kind: \"get\",\n        key: \"isVirtual\",\n        value: function isVirtual() {\n          return false;\n        }\n      }, {\n        kind: \"get\",\n        decorators: [flow],\n        key: \"lineBoundings\",\n        value: function lineBoundings() {\n          var lw = this.attr('lineWidth');\n\n          if (this.attr('shape')) {\n            var svgpath = new _svgPathToCanvas.default(this.attr('shape'));\n            svgpath.scale(this.attr('shapeScale')).lineWidth(lw).trim();\n            return [-lw, -lw].concat((0, _toConsumableArray2.default)(svgpath.size.map(function (v) {\n              return v += lw;\n            })));\n          }\n\n          var len = lw + this.attr('radius') + this.attr('offset');\n          return [lw, lw, 2 * len, 2 * len];\n        }\n      }, {\n        kind: \"get\",\n        decorators: [flow],\n        key: \"contentSize\",\n        value: function contentSize() {\n          var bounds = this.lineBoundings;\n\n          var _this$attrSize = (0, _slicedToArray2.default)(this.attrSize, 2),\n              width = _this$attrSize[0],\n              height = _this$attrSize[1];\n\n          if (width == '') {\n            width = bounds[2] - Math.min(0, bounds[0]);\n          }\n\n          if (height == '') {\n            height = bounds[3] - Math.min(0, bounds[1]);\n          }\n\n          return [width, height].map(Math.ceil);\n        }\n      }, {\n        kind: \"get\",\n        decorators: [flow],\n        key: \"originalRect\",\n        value: function originalRect() {\n          var lineBoundings = this.lineBoundings;\n\n          var _get2 = (0, _get4.default)((0, _getPrototypeOf3.default)(Wave.prototype), \"originalRect\", this),\n              _get3 = (0, _slicedToArray2.default)(_get2, 4),\n              x = _get3[0],\n              y = _get3[1],\n              w = _get3[2],\n              h = _get3[3];\n\n          var rect = [x - lineBoundings[0] / 2, y - lineBoundings[1] / 2, w, h];\n          return rect;\n        }\n      }, {\n        kind: \"method\",\n        key: \"render\",\n        value: function render(t, ctx) {\n          var _this3 = this;\n\n          (0, _get4.default)((0, _getPrototypeOf3.default)(Wave.prototype), \"render\", this).call(this, t, ctx);\n          var lw = this.attr('lineWidth');\n          var radius = this.attr('radius');\n          var offset = this.attr('offset');\n          var shape = this.attr('shape');\n          var showOutline = this.attr('showOutline');\n          var AMPLITUDE = this.attr('amplitude') || radius / 10;\n          ctx.save();\n          var cx;\n          var cy;\n          var horizontalLength;\n          var verticalLength;\n          var svgpath;\n\n          if (!shape) {\n            cx = lw + radius + offset;\n            cy = lw + radius + offset;\n            horizontalLength = verticalLength = radius;\n          } else {\n            svgpath = new _svgPathToCanvas.default(shape);\n\n            var _svgpath$center = (0, _slicedToArray2.default)(svgpath.center, 2);\n\n            cx = _svgpath$center[0];\n            cy = _svgpath$center[1];\n\n            var _svgpath$size$map = svgpath.size.map(function (v) {\n              return (v + lw) / 2;\n            });\n\n            var _svgpath$size$map2 = (0, _slicedToArray2.default)(_svgpath$size$map, 2);\n\n            horizontalLength = _svgpath$size$map2[0];\n            verticalLength = _svgpath$size$map2[1];\n          }\n\n          if (showOutline && !svgpath) {\n            // 外接圆\n            ctx.beginPath();\n            ctx.strokeStyle = this.attr('outlineColor');\n            ctx.lineWidth = lw;\n            ctx.arc(cx, cy, Math.min(horizontalLength, verticalLength) + offset, 0, Math.PI * 2, false);\n            ctx.stroke();\n          }\n\n          if (!svgpath) {\n            // 内接圆设为剪辑区域;\n            ctx.beginPath();\n            ctx.arc(cx, cy + 0, Math.min(horizontalLength, verticalLength), 0, Math.PI * 2, false);\n          } else {\n            ctx.translate(lw, lw);\n            svgpath.save().beginPath().strokeStyle(this.attr('shapeColor')).fillStyle(this.attr('shapeFillColor')).scale(this.attr('shapeScale')).lineWidth(lw).trim().to(ctx).fill().stroke();\n\n            var _svgpath$center2 = (0, _slicedToArray2.default)(svgpath.center, 2);\n\n            cx = _svgpath$center2[0];\n            cy = _svgpath$center2[1];\n\n            var _svgpath$size$map3 = svgpath.size.map(function (v) {\n              return (v + lw * 2) / 2;\n            });\n\n            var _svgpath$size$map4 = (0, _slicedToArray2.default)(_svgpath$size$map3, 2);\n\n            horizontalLength = _svgpath$size$map4[0];\n            verticalLength = _svgpath$size$map4[1];\n          }\n\n          ctx.clip(); // 绘制正弦曲线\n\n          var colors = this.attr('wavesColor');\n          var percent = this.attr('percent');\n\n          if (!Array.isArray(percent)) {\n            percent = [percent];\n          }\n\n          if (!Array.isArray(colors)) {\n            colors = [colors];\n          }\n\n          percent.map(function (percent, i) {\n            percent = percent > 1 ? 1 : percent;\n            var y = 0;\n\n            if (_this3.attr('shape')) {\n              // 使用 svgPath\n              y = -(percent - 0.5) * verticalLength * 2;\n            } else {\n              var startAngle = 0;\n\n              if (percent <= 0.5) {\n                startAngle = 0.25 - percent / 2;\n              } else if (percent < 1) {\n                startAngle = 0 - (percent - 0.5) / 2;\n              } else {\n                startAngle = 0;\n              }\n\n              startAngle *= Math.PI * 2;\n              var sinVal = percent >= 1 ? -1 : (0, _util.sin)(startAngle / 2);\n              y = (0, _util.round)(radius * sinVal);\n            }\n\n            var A = (radius / 20 * (0, _util.sin)(percent * Math.PI) + i * 10 + AMPLITUDE) / 2; // 振幅;\n\n            var W = Math.PI * 2 / 200;\n            var H = cy + y + i * 5;\n\n            var Q = _this3.attr('speed');\n\n            ctx.beginPath();\n            ctx.moveTo(cx - horizontalLength, cy);\n\n            for (var x = cx - horizontalLength; x <= cx + horizontalLength; x++) {\n              // 三角函数公式：y=Asin（wx+φ）+h\n              var _y = A * (i % 2 ? Math.sin : Math.cos)(W * x + Q) + H;\n\n              ctx.lineTo(x, _y);\n            } // 向下形成闭合区域\n\n\n            ctx.lineTo(cx + horizontalLength, cy + verticalLength);\n            ctx.lineTo(cx - horizontalLength, cy + verticalLength);\n            ctx.lineTo(cx - horizontalLength, cy);\n            ctx.fillStyle = colors[i] || colors[0];\n            ctx.fill();\n            ctx.closePath();\n          });\n          ctx.restore();\n        }\n      }]\n    };\n  }, Shape);\n\n  registerNodeType('wave', Wave, false);\n  return {\n    Wave: Wave\n  };\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _get4 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf3 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _shape = _interopRequireDefault(require(\"./shape\"));\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return (0, _toArray2.default)(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return (0, _typeof2.default)(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if ((0, _typeof2.default)(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if ((0, _typeof2.default)(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction install(_ref) {\n  var use = _ref.use,\n      utils = _ref.utils,\n      registerNodeType = _ref.registerNodeType;\n  var attr = utils.attr,\n      flow = utils.flow,\n      findColor = utils.findColor;\n\n  var _use = use(_shape.default, null, false),\n      Shape = _use.Shape;\n\n  var reflow = true;\n\n  var RingAttr = _decorate(null, function (_initialize, _Shape$Attr) {\n    var RingAttr =\n    /*#__PURE__*/\n    function (_Shape$Attr2) {\n      (0, _inherits2.default)(RingAttr, _Shape$Attr2);\n\n      function RingAttr(subject) {\n        var _this;\n\n        (0, _classCallCheck2.default)(this, RingAttr);\n        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf3.default)(RingAttr).call(this, subject));\n\n        _initialize((0, _assertThisInitialized2.default)(_this));\n\n        _this.setDefault({\n          innerRaius: 10,\n          outerRadius: 20,\n          startAngle: 0,\n          endAngle: Math.PI * 2,\n          lineWidth: 1,\n          maxRadius: 0 // 当需要绘制多个环且环的半径不一致,为了统一圆心,所设属性\n\n        });\n\n        return _this;\n      } // 内圆半径\n\n\n      return RingAttr;\n    }(_Shape$Attr);\n\n    return {\n      F: RingAttr,\n      d: [{\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"innerRadius\",\n        value: function innerRadius(val) {\n          this.set('innerRadius', val);\n        } // 外圆半径\n\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"outerRadius\",\n        value: function outerRadius(val) {\n          this.set('outerRadius', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"maxRadius\",\n        value: function maxRadius(val) {\n          this.set('maxRadius', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"startAngle\",\n        value: function startAngle(val) {\n          this.set('startAngle', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"endAngle\",\n        value: function endAngle(val) {\n          this.set('endAngle', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"center\",\n        value: function center(val) {\n          this.set('center', val);\n        }\n      }]\n    };\n  }, Shape.Attr);\n\n  var Ring = _decorate(null, function (_initialize2, _Shape) {\n    var Ring =\n    /*#__PURE__*/\n    function (_Shape2) {\n      (0, _inherits2.default)(Ring, _Shape2);\n\n      function Ring() {\n        var _getPrototypeOf2;\n\n        var _this2;\n\n        (0, _classCallCheck2.default)(this, Ring);\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this2 = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Ring)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n        _initialize2((0, _assertThisInitialized2.default)(_this2));\n\n        return _this2;\n      }\n\n      return Ring;\n    }(_Shape);\n\n    return {\n      F: Ring,\n      d: [{\n        kind: \"field\",\n        static: true,\n        key: \"Attr\",\n        value: function value() {\n          return RingAttr;\n        }\n      }, {\n        kind: \"get\",\n        key: \"lineBoundings\",\n        value: // 边界依赖于最大圆\n        function lineBoundings() {\n          var maxRadius = this.attr('maxRadius');\n\n          if (maxRadius <= 0) {\n            var radius = Math.max(this.attr('innerRadius'), this.attr('outerRadius'));\n            maxRadius = radius;\n          }\n\n          return [0, 0, 2 * maxRadius, 2 * maxRadius];\n        }\n      }, {\n        kind: \"get\",\n        key: \"startAngle\",\n        value: function startAngle() {\n          return this.attr('startAngle');\n        }\n      }, {\n        kind: \"get\",\n        key: \"endAngle\",\n        value: function endAngle() {\n          return this.attr('endAngle');\n        }\n      }, {\n        kind: \"get\",\n        decorators: [flow],\n        key: \"contentSize\",\n        value: function contentSize() {\n          var bounds = this.lineBoundings;\n          var lw = this.attr('lineWidth');\n\n          var _this$attrSize = (0, _slicedToArray2.default)(this.attrSize, 2),\n              width = _this$attrSize[0],\n              height = _this$attrSize[1];\n\n          width = bounds[2] - Math.min(0, bounds[0]);\n          height = bounds[3] - Math.min(0, bounds[1]);\n          return [width, height].map(Math.ceil);\n        }\n      }, {\n        kind: \"get\",\n        decorators: [flow],\n        key: \"originalRect\",\n        value: function originalRect() {\n          var lineBoundings = this.lineBoundings;\n          var lw = this.attr('lineWidth');\n\n          var _get2 = (0, _get4.default)((0, _getPrototypeOf3.default)(Ring.prototype), \"originalRect\", this),\n              _get3 = (0, _slicedToArray2.default)(_get2, 4),\n              x = _get3[0],\n              y = _get3[1],\n              w = _get3[2],\n              h = _get3[3];\n\n          var rect = [x - lineBoundings[0] / 2, y - lineBoundings[1] / 2, w, h];\n          return rect;\n        }\n      }, {\n        kind: \"method\",\n        key: \"pointCollision\",\n        value: function pointCollision(evt) {\n          if ((0, _get4.default)((0, _getPrototypeOf3.default)(Ring.prototype), \"pointCollision\", this).call(this, evt)) {\n            var offsetX = evt.offsetX,\n                offsetY = evt.offsetY;\n\n            var _this$attr = this.attr('anchor'),\n                _this$attr2 = (0, _slicedToArray2.default)(_this$attr, 2),\n                anchorX = _this$attr2[0],\n                anchorY = _this$attr2[1];\n\n            var _this$contentSize = (0, _slicedToArray2.default)(this.contentSize, 2),\n                width = _this$contentSize[0],\n                height = _this$contentSize[1];\n\n            offsetX += width * anchorX;\n            offsetY += height * anchorY;\n            var r = this.attr('maxRadius');\n            var offset = this.attr('outerRadius'); // 偏移量\n\n            if (r <= 0) {\n              r = offset;\n            }\n\n            offset = r - offset; // 如果未设置maxRadius，偏移量应当０\n\n            var r0 = this.attr('innerRadius');\n            var TAU = Math.PI * 2;\n            var startAngle = this.attr('startAngle');\n\n            if (startAngle > TAU) {\n              startAngle %= TAU;\n            } else {\n              startAngle = (startAngle + Math.ceil(Math.abs(startAngle) / TAU) * TAU) % TAU;\n            }\n\n            var endAngle = this.attr('endAngle') - this.attr('startAngle') + startAngle;\n            var d = Math.sqrt(Math.pow(offsetX - r, 2) + Math.pow(offsetY - r, 2));\n            var angle = Math.atan2(offsetY - r, offsetX - r);\n\n            if (angle < 0 || endAngle > TAU) {\n              angle += TAU;\n            }\n\n            return d >= r0 && d <= r - offset && angle >= startAngle && angle <= endAngle;\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"render\",\n        value: function render(t, ctx) {\n          (0, _get4.default)((0, _getPrototypeOf3.default)(Ring.prototype), \"render\", this).call(this, t, ctx);\n          var innerRadius = Math.min(this.attr('innerRadius'), this.attr('outerRadius'));\n          var outerRadius = Math.max(this.attr('innerRadius'), this.attr('outerRadius'));\n          var lw = this.attr('lineWidth');\n          var startAngle = this.startAngle;\n          var endAngle = this.endAngle;\n          ctx.miterLimit = 0;\n          ctx.lineWidth = lw;\n          ctx.lineCap = this.attr('lineCap');\n          ctx.lineJoin = this.attr('lineJoin');\n          ctx.setLineDash(this.attr('lineDash'));\n          ctx.lineDashOffset = this.attr('lineDashOffset');\n          ctx.strokeStyle = findColor(ctx, this, 'strokeColor');\n          ctx.fillStyle = findColor(ctx, this, 'fillColor');\n          var x = 0,\n              y = 0;\n          var maxRadius = this.attr('maxRadius');\n\n          if (maxRadius <= 0) {\n            maxRadius = outerRadius;\n          }\n\n          var lineBoundings = this.lineBoundings;\n          ctx.translate(lineBoundings[2] / 2 - x, lineBoundings[3] / 2 - y);\n          ctx.beginPath();\n          ctx.arc(x, y, Math.max(0, outerRadius - lw / 2), startAngle, endAngle, false);\n\n          if (endAngle - startAngle === Math.PI * 2) {\n            ctx.moveTo(outerRadius + innerRadius, outerRadius);\n          }\n\n          ctx.arc(x, y, Math.max(0, innerRadius - lw / 2), endAngle, startAngle, true);\n          ctx.closePath();\n          ctx.fill();\n\n          if (lw > 0) {\n            ctx.stroke();\n          }\n\n          return ctx;\n        }\n      }]\n    };\n  }, Shape);\n\n  registerNodeType('ring', Ring);\n  return {\n    Ring: Ring\n  };\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _toConsumableArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toConsumableArray\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _get2 = _interopRequireDefault(require(\"@babel/runtime/helpers/get\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf3 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _shape = _interopRequireDefault(require(\"./shape\"));\n\nvar _svgPathToCanvas = _interopRequireDefault(require(\"svg-path-to-canvas\"));\n\nvar _util = require(\"./util\");\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return (0, _toArray2.default)(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return (0, _typeof2.default)(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if ((0, _typeof2.default)(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if ((0, _typeof2.default)(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction install(_ref) {\n  var use = _ref.use,\n      utils = _ref.utils,\n      registerNodeType = _ref.registerNodeType;\n  var attr = utils.attr,\n      flow = utils.flow,\n      parseColorString = utils.parseColorString,\n      findColor = utils.findColor;\n\n  var _use = use(_shape.default, null, false),\n      Shape = _use.Shape;\n\n  var reflow = true;\n\n  var PolygonAttr = _decorate(null, function (_initialize, _Shape$Attr) {\n    var PolygonAttr =\n    /*#__PURE__*/\n    function (_Shape$Attr2) {\n      (0, _inherits2.default)(PolygonAttr, _Shape$Attr2);\n\n      function PolygonAttr(subject) {\n        var _this;\n\n        (0, _classCallCheck2.default)(this, PolygonAttr);\n        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf3.default)(PolygonAttr).call(this, subject));\n\n        _initialize((0, _assertThisInitialized2.default)(_this));\n\n        _this.setDefault({\n          points: [],\n          smooth: null\n        });\n\n        return _this;\n      }\n\n      return PolygonAttr;\n    }(_Shape$Attr);\n\n    return {\n      F: PolygonAttr,\n      d: [{\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"smooth\",\n        value: function smooth(val) {\n          this.set('smooth', val);\n          this.subject.path = null;\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"points\",\n        value: function points(val) {\n          this.set('points', val);\n          this.subject.path = null;\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"lineWidth\",\n        value: function lineWidth(val) {\n          this.set('lineWidth', val);\n          this.subject.path = null;\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr],\n        key: \"fillColor\",\n        value: function fillColor(val) {\n          val = parseColorString(val);\n          this.set('fillColor', val);\n        }\n      }]\n    };\n  }, Shape.Attr);\n\n  var Polygon = _decorate(null, function (_initialize2, _Shape) {\n    var Polygon =\n    /*#__PURE__*/\n    function (_Shape2) {\n      (0, _inherits2.default)(Polygon, _Shape2);\n\n      function Polygon() {\n        var _getPrototypeOf2;\n\n        var _this2;\n\n        (0, _classCallCheck2.default)(this, Polygon);\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this2 = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Polygon)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n        _initialize2((0, _assertThisInitialized2.default)(_this2));\n\n        return _this2;\n      }\n\n      return Polygon;\n    }(_Shape);\n\n    return {\n      F: Polygon,\n      d: [{\n        kind: \"field\",\n        static: true,\n        key: \"Attr\",\n        value: function value() {\n          return PolygonAttr;\n        }\n      }, {\n        kind: \"get\",\n        key: \"lineBoundings\",\n        value: function lineBoundings() {\n          var bounds = [0, 0, 0, 0];\n          var points = this.attr('points');\n          points.forEach(function (_ref2) {\n            var _ref3 = (0, _slicedToArray2.default)(_ref2, 2),\n                x = _ref3[0],\n                y = _ref3[1];\n\n            bounds[0] = Math.min(x, bounds[0]);\n            bounds[1] = Math.min(y, bounds[1]);\n            bounds[2] = Math.max(x, bounds[2]);\n            bounds[3] = Math.max(y, bounds[3]);\n          });\n          return bounds;\n        }\n      }, {\n        kind: \"get\",\n        decorators: [flow],\n        key: \"contentSize\",\n        value: function contentSize() {\n          var lw = this.attr('lineWidth');\n          var bounds = this.lineBoundings;\n\n          var _this$attrSize = (0, _slicedToArray2.default)(this.attrSize, 2),\n              width = _this$attrSize[0],\n              height = _this$attrSize[1];\n\n          width = bounds[2] - bounds[0] + lw;\n          height = bounds[3] - bounds[1] + lw;\n          return [width, height].map(Math.ceil);\n        }\n      }, {\n        kind: \"get\",\n        key: \"translate\",\n        value: function translate() {\n          var lw = this.attr('lineWidth');\n          return [lw / 2, lw / 2];\n        }\n      }, {\n        kind: \"get\",\n        key: \"points\",\n        value: function points() {\n          return this.attr('points');\n        }\n      }, {\n        kind: \"method\",\n        key: \"pointCollision\",\n        value: function pointCollision(evt) {\n          if ((0, _get2.default)((0, _getPrototypeOf3.default)(Polygon.prototype), \"pointCollision\", this).call(this, evt)) {\n            var _evt$offsetX = evt.offsetX,\n                offsetX = _evt$offsetX === void 0 ? 0 : _evt$offsetX,\n                _evt$offsetY = evt.offsetY,\n                offsetY = _evt$offsetY === void 0 ? 0 : _evt$offsetY;\n\n            var _this$attr = this.attr('anchor'),\n                _this$attr2 = (0, _slicedToArray2.default)(_this$attr, 2),\n                anchorX = _this$attr2[0],\n                anchorY = _this$attr2[1];\n\n            var _this$contentSize = (0, _slicedToArray2.default)(this.contentSize, 2),\n                width = _this$contentSize[0],\n                height = _this$contentSize[1];\n\n            offsetX += width * anchorX;\n            offsetY += height * anchorY;\n            var path = this.path;\n\n            if (path) {\n              var lineWidth = this.attr('lineWidth'),\n                  lineCap = this.attr('lineCap'),\n                  lineJoin = this.attr('lineJoin');\n              return path.isPointInPath(offsetX, offsetY) || path.isPointInStroke(offsetX, offsetY, {\n                lineWidth: lineWidth,\n                lineCap: lineCap,\n                lineJoin: lineJoin\n              });\n            }\n          }\n        }\n      }, {\n        kind: \"method\",\n        key: \"render\",\n        value: function render(t, drawingContext) {\n          (0, _get2.default)((0, _getPrototypeOf3.default)(Polygon.prototype), \"render\", this).call(this, t, drawingContext);\n\n          if (this.points.length) {\n            var translate = this.translate;\n            drawingContext.translate(translate[0], translate[1]);\n            drawingContext.strokeStyle = findColor(drawingContext, this, 'strokeColor');\n            drawingContext.fillStyle = findColor(drawingContext, this, 'fillColor');\n            drawingContext.miterLimit = 3;\n            drawingContext.lineCap = this.attr('lineCap');\n            drawingContext.lineJoin = this.attr('lineJoin');\n            drawingContext.lineWidth = this.attr('lineWidth');\n            drawingContext.setLineDash(this.attr('lineDash'));\n            drawingContext.lineDashOffset = this.attr('lineDashOffset');\n\n            if (!this.path || !(0, _util.pointsEqual)(this.path.points, this.points)) {\n              var smooth = this.attr('smooth');\n              var points = this.points.slice(0, this.points.length);\n\n              if (smooth && !smooth.length) {\n                smooth = [0, points.length - 1];\n              }\n\n              var d = ''; // 绘制光滑曲线（直线）\n\n              if (!smooth) {\n                points.forEach(function (point, i) {\n                  if (i === 0) {\n                    d += \"M\".concat(point.join(' '));\n                  } else {\n                    d += \"L\".concat(point.join(' '));\n                  }\n                });\n              } else {\n                if (Object.prototype.toString.call(smooth[0]) !== '[object Array]') {\n                  // 如果不是多维数组，转成多维\n                  smooth = [smooth];\n                }\n\n                var startPos = points[0];\n                var endPos = points[points.length - 1];\n\n                if (startPos[0] !== endPos[0] || startPos[1] !== endPos[1]) {\n                  points.push(points[0]);\n                }\n\n                var subIndex = 0;\n                smooth.forEach(function (arr, iind) {\n                  var smoothStart = arr[0];\n                  var smoothEnd = arr[1];\n\n                  for (var i = subIndex; i < smoothStart; i++) {\n                    if (i === 0) {\n                      // 如果是所有线条的起始点\n                      d += \"M\".concat(points[0].join(' '));\n                    } else {\n                      // 如果是转换点\n                      d += \"L\".concat(points[i].join(' '));\n                    }\n                  }\n\n                  var smoothPoints = points.slice(smoothStart, smoothEnd + 1);\n                  d += (0, _util.makeSmoothCurveLine)(smoothPoints, smoothStart);\n                  subIndex = smoothEnd;\n                });\n\n                for (var i = subIndex; i < points.length - 1; i++) {\n                  // 如果绘图未绘制到最后一个点\n                  d += \"L\".concat(points[i].join(' '));\n                }\n              }\n\n              d += 'Z';\n              this.path = new _svgPathToCanvas.default(d);\n              this.path.points = (0, _toConsumableArray2.default)(this.points);\n            }\n\n            if (this.path) {\n              this.path.beginPath().to(drawingContext);\n              drawingContext.fill();\n              drawingContext.stroke();\n            }\n          }\n\n          return drawingContext;\n        }\n      }]\n    };\n  }, Shape);\n\n  registerNodeType('polygon', Polygon, false);\n  return {\n    Polygon: Polygon\n  };\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _polygon = _interopRequireDefault(require(\"./polygon\"));\n\nfunction install(_ref) {\n  var use = _ref.use,\n      utils = _ref.utils,\n      registerNodeType = _ref.registerNodeType;\n\n  var _use = use(_polygon.default, null, false),\n      Polygon = _use.Polygon;\n\n  var Triangle =\n  /*#__PURE__*/\n  function (_Polygon) {\n    (0, _inherits2.default)(Triangle, _Polygon);\n\n    function Triangle() {\n      (0, _classCallCheck2.default)(this, Triangle);\n      return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Triangle).apply(this, arguments));\n    }\n\n    (0, _createClass2.default)(Triangle, [{\n      key: \"contentSize\",\n      get: function get() {\n        var _this$attr = this.attr('sides'),\n            _this$attr2 = (0, _slicedToArray2.default)(_this$attr, 2),\n            s1 = _this$attr2[0],\n            s2 = _this$attr2[1];\n\n        return [s1, s2];\n      }\n    }, {\n      key: \"points\",\n      get: function get() {\n        var _this$attr3 = this.attr('sides'),\n            _this$attr4 = (0, _slicedToArray2.default)(_this$attr3, 2),\n            s1 = _this$attr4[0],\n            s2 = _this$attr4[1];\n\n        var lw = this.attr('lineWidth');\n        s1 -= lw * 2;\n        s2 -= lw * 2;\n        var angle = Math.PI / 180 * this.attr('angle');\n        var p0 = [0, 0];\n        var p1 = [s1, 0];\n        var p2 = [s2 * Math.cos(angle), s2 * Math.sin(angle)];\n        return [p0, p1, p2];\n      }\n    }]);\n    return Triangle;\n  }(Polygon);\n\n  registerNodeType('triangle', Triangle, false);\n  return {\n    Triangle: Triangle\n  };\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf3 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _polygon = _interopRequireDefault(require(\"./polygon\"));\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return (0, _toArray2.default)(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return (0, _typeof2.default)(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if ((0, _typeof2.default)(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if ((0, _typeof2.default)(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction install(_ref) {\n  var use = _ref.use,\n      utils = _ref.utils,\n      registerNodeType = _ref.registerNodeType;\n  var attr = utils.attr,\n      flow = utils.flow;\n\n  var _use = use(_polygon.default, null, false),\n      Polygon = _use.Polygon;\n\n  var reflow = true;\n\n  var rectAttr = _decorate(null, function (_initialize, _Polygon$Attr) {\n    var rectAttr =\n    /*#__PURE__*/\n    function (_Polygon$Attr2) {\n      (0, _inherits2.default)(rectAttr, _Polygon$Attr2);\n\n      function rectAttr(subject) {\n        var _this;\n\n        (0, _classCallCheck2.default)(this, rectAttr);\n        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf3.default)(rectAttr).call(this, subject));\n\n        _initialize((0, _assertThisInitialized2.default)(_this));\n\n        _this.setDefault({\n          angle: 90,\n          sides: null,\n          size: null\n        });\n\n        return _this;\n      }\n\n      return rectAttr;\n    }(_Polygon$Attr);\n\n    return {\n      F: rectAttr,\n      d: [{\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"angle\",\n        value: function angle(val) {\n          this.set('angle', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"sides\",\n        value: function sides(val) {\n          this.set('sides', val);\n        }\n      }]\n    };\n  }, Polygon.Attr);\n\n  var Rect = _decorate(null, function (_initialize2, _Polygon) {\n    var Rect =\n    /*#__PURE__*/\n    function (_Polygon2) {\n      (0, _inherits2.default)(Rect, _Polygon2);\n\n      function Rect() {\n        var _getPrototypeOf2;\n\n        var _this2;\n\n        (0, _classCallCheck2.default)(this, Rect);\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this2 = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Rect)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n        _initialize2((0, _assertThisInitialized2.default)(_this2));\n\n        return _this2;\n      }\n\n      return Rect;\n    }(_Polygon);\n\n    return {\n      F: Rect,\n      d: [{\n        kind: \"field\",\n        static: true,\n        key: \"Attr\",\n        value: function value() {\n          return rectAttr;\n        }\n      }, {\n        kind: \"get\",\n        key: \"lineBoundings\",\n        value: function lineBoundings() {\n          var lw = this.attr('lineWidth');\n          var bounds = [0, 0, 0, 0];\n          var points = this.points;\n          points.forEach(function (_ref2) {\n            var _ref3 = (0, _slicedToArray2.default)(_ref2, 2),\n                x = _ref3[0],\n                y = _ref3[1];\n\n            x += lw;\n            y += lw;\n            bounds[0] = Math.min(x, bounds[0]);\n            bounds[1] = Math.min(y, bounds[1]);\n            bounds[2] = Math.max(x, bounds[2]);\n            bounds[3] = Math.max(y, bounds[3]);\n          });\n          return bounds;\n        }\n      }, {\n        kind: \"get\",\n        decorators: [flow],\n        key: \"contentSize\",\n        value: function contentSize() {\n          var lw = this.attr('lineWidth');\n          var bounds = this.lineBoundings;\n\n          var _this$attrSize = (0, _slicedToArray2.default)(this.attrSize, 2),\n              width = _this$attrSize[0],\n              height = _this$attrSize[1];\n\n          width = bounds[2] - bounds[0];\n          height = bounds[3] - bounds[1];\n          return [width, height].map(Math.ceil);\n        }\n      }, {\n        kind: \"get\",\n        key: \"points\",\n        value: function points() {\n          var lw = this.attr('lineWidth');\n\n          var _ref4 = this.attr('sides') || this.attr('size'),\n              _ref5 = (0, _slicedToArray2.default)(_ref4, 2),\n              s1 = _ref5[0],\n              s2 = _ref5[1];\n\n          s1 -= lw * 1;\n          s2 -= lw * 1;\n          var oAngle = this.attr('angle');\n          var cosAngle = 0;\n          var sinAngle = 1;\n\n          if (oAngle === 90) {// 90默认不处理\n          } else {\n            var angle = Math.PI * this.attr('angle') / 180;\n            cosAngle = Math.cos(angle);\n            sinAngle = Math.sin(angle);\n          }\n\n          var p0 = [0, 0];\n          var p1 = [s1, 0];\n          var p2 = [s1 + s2 * cosAngle, s2 * sinAngle];\n          var p3 = [s2 * cosAngle, s2 * sinAngle];\n          return [p0, p1, p2, p3];\n        }\n      }]\n    };\n  }, Polygon);\n\n  registerNodeType('rect', Rect, false);\n  return {\n    Rect: Rect\n  };\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/slicedToArray\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf3 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _polygon = _interopRequireDefault(require(\"./polygon\"));\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return (0, _toArray2.default)(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return (0, _typeof2.default)(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if ((0, _typeof2.default)(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if ((0, _typeof2.default)(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction polygonPoints(outerRadius, innerRadius, number, lw) {\n  var center = outerRadius;\n  var radAngle = Math.PI / 2;\n  var radAlpha = Math.PI / number;\n  var points = [];\n\n  for (var i = 1; i <= number * 2; i++) {\n    var r = i % 2 ? outerRadius - lw : innerRadius;\n    var alpha = radAlpha * i + radAngle;\n    var x = center + r * Math.cos(alpha);\n    var y = center + r * Math.sin(alpha);\n    points.push([x, y]);\n  }\n\n  return points;\n}\n\nfunction install(_ref) {\n  var use = _ref.use,\n      utils = _ref.utils,\n      registerNodeType = _ref.registerNodeType;\n  var attr = utils.attr,\n      flow = utils.flow;\n\n  var _use = use(_polygon.default, null, false),\n      Polygon = _use.Polygon;\n\n  var reflow = true;\n\n  var PolygonAttr = _decorate(null, function (_initialize, _Polygon$Attr) {\n    var PolygonAttr =\n    /*#__PURE__*/\n    function (_Polygon$Attr2) {\n      (0, _inherits2.default)(PolygonAttr, _Polygon$Attr2);\n\n      function PolygonAttr(subject) {\n        var _this;\n\n        (0, _classCallCheck2.default)(this, PolygonAttr);\n        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf3.default)(PolygonAttr).call(this, subject));\n\n        _initialize((0, _assertThisInitialized2.default)(_this));\n\n        _this.setDefault({\n          angles: 5\n        });\n\n        return _this;\n      }\n\n      return PolygonAttr;\n    }(_Polygon$Attr);\n\n    return {\n      F: PolygonAttr,\n      d: [{\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"angles\",\n        value: function angles(num) {\n          this.set('angles', num);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"radius\",\n        value: function radius(val) {\n          // 圆半径\n          this.set('radius', val);\n        }\n      }, {\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"innerRadius\",\n        value: function innerRadius(val) {\n          this.set('innerRadius', val);\n        }\n      }]\n    };\n  }, Polygon.Attr);\n\n  var Star = _decorate(null, function (_initialize2, _Polygon) {\n    var Star =\n    /*#__PURE__*/\n    function (_Polygon2) {\n      (0, _inherits2.default)(Star, _Polygon2);\n\n      function Star() {\n        var _getPrototypeOf2;\n\n        var _this2;\n\n        (0, _classCallCheck2.default)(this, Star);\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        _this2 = (0, _possibleConstructorReturn2.default)(this, (_getPrototypeOf2 = (0, _getPrototypeOf3.default)(Star)).call.apply(_getPrototypeOf2, [this].concat(args)));\n\n        _initialize2((0, _assertThisInitialized2.default)(_this2));\n\n        return _this2;\n      }\n\n      return Star;\n    }(_Polygon);\n\n    return {\n      F: Star,\n      d: [{\n        kind: \"field\",\n        static: true,\n        key: \"Attr\",\n        value: function value() {\n          return PolygonAttr;\n        }\n      }, {\n        kind: \"get\",\n        key: \"lineBoundings\",\n        value: function lineBoundings() {\n          var radius = this.attr('radius');\n          return [0, 0, radius * 2, radius * 2];\n        }\n      }, {\n        kind: \"get\",\n        decorators: [flow],\n        key: \"contentSize\",\n        value: function contentSize() {\n          var lw = this.attr('lineWidth');\n          var bounds = this.lineBoundings;\n\n          var _this$attrSize = (0, _slicedToArray2.default)(this.attrSize, 2),\n              width = _this$attrSize[0],\n              height = _this$attrSize[1];\n\n          width = bounds[2] - bounds[0];\n          height = bounds[3] - bounds[1];\n          return [width, height].map(Math.ceil);\n        }\n      }, {\n        kind: \"get\",\n        key: \"translate\",\n        value: function translate() {\n          return [0, 0];\n        }\n      }, {\n        kind: \"get\",\n        key: \"points\",\n        value: function points() {\n          var radius = this.attr('radius');\n          var lw = this.attr('lineWidth');\n          var innerRadius = this.attr('innerRadius') || 0.5 * radius;\n          return polygonPoints(radius, innerRadius, this.attr('angles'), lw);\n        }\n      }]\n    };\n  }, Polygon);\n\n  registerNodeType('star', Star, false);\n  return {\n    Star: Star\n  };\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _ellipseSector = _interopRequireDefault(require(\"./ellipseSector\"));\n\nfunction install(_ref) {\n  var use = _ref.use,\n      utils = _ref.utils,\n      registerNodeType = _ref.registerNodeType;\n\n  var _use = use(_ellipseSector.default, null, false),\n      EllipseSector = _use.EllipseSector;\n\n  var Ellipse =\n  /*#__PURE__*/\n  function (_EllipseSector) {\n    (0, _inherits2.default)(Ellipse, _EllipseSector);\n\n    function Ellipse() {\n      (0, _classCallCheck2.default)(this, Ellipse);\n      return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Ellipse).apply(this, arguments));\n    }\n\n    (0, _createClass2.default)(Ellipse, [{\n      key: \"startAngle\",\n      get: function get() {\n        return 0;\n      }\n    }, {\n      key: \"endAngle\",\n      get: function get() {\n        return 2 * Math.PI;\n      }\n    }]);\n    return Ellipse;\n  }(EllipseSector);\n\n  registerNodeType('ellipse', Ellipse, false);\n  return {\n    Ellipse: Ellipse\n  };\n}","\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = install;\n\nvar _typeof2 = _interopRequireDefault(require(\"@babel/runtime/helpers/typeof\"));\n\nvar _createClass2 = _interopRequireDefault(require(\"@babel/runtime/helpers/createClass\"));\n\nvar _defineProperty2 = _interopRequireDefault(require(\"@babel/runtime/helpers/defineProperty\"));\n\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\n\nvar _possibleConstructorReturn2 = _interopRequireDefault(require(\"@babel/runtime/helpers/possibleConstructorReturn\"));\n\nvar _getPrototypeOf2 = _interopRequireDefault(require(\"@babel/runtime/helpers/getPrototypeOf\"));\n\nvar _assertThisInitialized2 = _interopRequireDefault(require(\"@babel/runtime/helpers/assertThisInitialized\"));\n\nvar _inherits2 = _interopRequireDefault(require(\"@babel/runtime/helpers/inherits\"));\n\nvar _toArray2 = _interopRequireDefault(require(\"@babel/runtime/helpers/toArray\"));\n\nvar _ellipse = _interopRequireDefault(require(\"./ellipse\"));\n\nfunction _decorate(decorators, factory, superClass, mixins) { var api = _getDecoratorsApi(); if (mixins) { for (var i = 0; i < mixins.length; i++) { api = mixins[i](api); } } var r = factory(function initialize(O) { api.initializeInstanceElements(O, decorated.elements); }, superClass); var decorated = api.decorateClass(_coalesceClassElements(r.d.map(_createElementDescriptor)), decorators); api.initializeClassElements(r.F, decorated.elements); return api.runClassFinishers(r.F, decorated.finishers); }\n\nfunction _getDecoratorsApi() { _getDecoratorsApi = function _getDecoratorsApi() { return api; }; var api = { elementsDefinitionOrder: [[\"method\"], [\"field\"]], initializeInstanceElements: function initializeInstanceElements(O, elements) { [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { if (element.kind === kind && element.placement === \"own\") { this.defineClassElement(O, element); } }, this); }, this); }, initializeClassElements: function initializeClassElements(F, elements) { var proto = F.prototype; [\"method\", \"field\"].forEach(function (kind) { elements.forEach(function (element) { var placement = element.placement; if (element.kind === kind && (placement === \"static\" || placement === \"prototype\")) { var receiver = placement === \"static\" ? F : proto; this.defineClassElement(receiver, element); } }, this); }, this); }, defineClassElement: function defineClassElement(receiver, element) { var descriptor = element.descriptor; if (element.kind === \"field\") { var initializer = element.initializer; descriptor = { enumerable: descriptor.enumerable, writable: descriptor.writable, configurable: descriptor.configurable, value: initializer === void 0 ? void 0 : initializer.call(receiver) }; } Object.defineProperty(receiver, element.key, descriptor); }, decorateClass: function decorateClass(elements, decorators) { var newElements = []; var finishers = []; var placements = { static: [], prototype: [], own: [] }; elements.forEach(function (element) { this.addElementPlacement(element, placements); }, this); elements.forEach(function (element) { if (!_hasDecorators(element)) return newElements.push(element); var elementFinishersExtras = this.decorateElement(element, placements); newElements.push(elementFinishersExtras.element); newElements.push.apply(newElements, elementFinishersExtras.extras); finishers.push.apply(finishers, elementFinishersExtras.finishers); }, this); if (!decorators) { return { elements: newElements, finishers: finishers }; } var result = this.decorateConstructor(newElements, decorators); finishers.push.apply(finishers, result.finishers); result.finishers = finishers; return result; }, addElementPlacement: function addElementPlacement(element, placements, silent) { var keys = placements[element.placement]; if (!silent && keys.indexOf(element.key) !== -1) { throw new TypeError(\"Duplicated element (\" + element.key + \")\"); } keys.push(element.key); }, decorateElement: function decorateElement(element, placements) { var extras = []; var finishers = []; for (var decorators = element.decorators, i = decorators.length - 1; i >= 0; i--) { var keys = placements[element.placement]; keys.splice(keys.indexOf(element.key), 1); var elementObject = this.fromElementDescriptor(element); var elementFinisherExtras = this.toElementFinisherExtras((0, decorators[i])(elementObject) || elementObject); element = elementFinisherExtras.element; this.addElementPlacement(element, placements); if (elementFinisherExtras.finisher) { finishers.push(elementFinisherExtras.finisher); } var newExtras = elementFinisherExtras.extras; if (newExtras) { for (var j = 0; j < newExtras.length; j++) { this.addElementPlacement(newExtras[j], placements); } extras.push.apply(extras, newExtras); } } return { element: element, finishers: finishers, extras: extras }; }, decorateConstructor: function decorateConstructor(elements, decorators) { var finishers = []; for (var i = decorators.length - 1; i >= 0; i--) { var obj = this.fromClassDescriptor(elements); var elementsAndFinisher = this.toClassDescriptor((0, decorators[i])(obj) || obj); if (elementsAndFinisher.finisher !== undefined) { finishers.push(elementsAndFinisher.finisher); } if (elementsAndFinisher.elements !== undefined) { elements = elementsAndFinisher.elements; for (var j = 0; j < elements.length - 1; j++) { for (var k = j + 1; k < elements.length; k++) { if (elements[j].key === elements[k].key && elements[j].placement === elements[k].placement) { throw new TypeError(\"Duplicated element (\" + elements[j].key + \")\"); } } } } } return { elements: elements, finishers: finishers }; }, fromElementDescriptor: function fromElementDescriptor(element) { var obj = { kind: element.kind, key: element.key, placement: element.placement, descriptor: element.descriptor }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); if (element.kind === \"field\") obj.initializer = element.initializer; return obj; }, toElementDescriptors: function toElementDescriptors(elementObjects) { if (elementObjects === undefined) return; return (0, _toArray2.default)(elementObjects).map(function (elementObject) { var element = this.toElementDescriptor(elementObject); this.disallowProperty(elementObject, \"finisher\", \"An element descriptor\"); this.disallowProperty(elementObject, \"extras\", \"An element descriptor\"); return element; }, this); }, toElementDescriptor: function toElementDescriptor(elementObject) { var kind = String(elementObject.kind); if (kind !== \"method\" && kind !== \"field\") { throw new TypeError('An element descriptor\\'s .kind property must be either \"method\" or' + ' \"field\", but a decorator created an element descriptor with' + ' .kind \"' + kind + '\"'); } var key = _toPropertyKey(elementObject.key); var placement = String(elementObject.placement); if (placement !== \"static\" && placement !== \"prototype\" && placement !== \"own\") { throw new TypeError('An element descriptor\\'s .placement property must be one of \"static\",' + ' \"prototype\" or \"own\", but a decorator created an element descriptor' + ' with .placement \"' + placement + '\"'); } var descriptor = elementObject.descriptor; this.disallowProperty(elementObject, \"elements\", \"An element descriptor\"); var element = { kind: kind, key: key, placement: placement, descriptor: Object.assign({}, descriptor) }; if (kind !== \"field\") { this.disallowProperty(elementObject, \"initializer\", \"A method descriptor\"); } else { this.disallowProperty(descriptor, \"get\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"set\", \"The property descriptor of a field descriptor\"); this.disallowProperty(descriptor, \"value\", \"The property descriptor of a field descriptor\"); element.initializer = elementObject.initializer; } return element; }, toElementFinisherExtras: function toElementFinisherExtras(elementObject) { var element = this.toElementDescriptor(elementObject); var finisher = _optionalCallableProperty(elementObject, \"finisher\"); var extras = this.toElementDescriptors(elementObject.extras); return { element: element, finisher: finisher, extras: extras }; }, fromClassDescriptor: function fromClassDescriptor(elements) { var obj = { kind: \"class\", elements: elements.map(this.fromElementDescriptor, this) }; var desc = { value: \"Descriptor\", configurable: true }; Object.defineProperty(obj, Symbol.toStringTag, desc); return obj; }, toClassDescriptor: function toClassDescriptor(obj) { var kind = String(obj.kind); if (kind !== \"class\") { throw new TypeError('A class descriptor\\'s .kind property must be \"class\", but a decorator' + ' created a class descriptor with .kind \"' + kind + '\"'); } this.disallowProperty(obj, \"key\", \"A class descriptor\"); this.disallowProperty(obj, \"placement\", \"A class descriptor\"); this.disallowProperty(obj, \"descriptor\", \"A class descriptor\"); this.disallowProperty(obj, \"initializer\", \"A class descriptor\"); this.disallowProperty(obj, \"extras\", \"A class descriptor\"); var finisher = _optionalCallableProperty(obj, \"finisher\"); var elements = this.toElementDescriptors(obj.elements); return { elements: elements, finisher: finisher }; }, runClassFinishers: function runClassFinishers(constructor, finishers) { for (var i = 0; i < finishers.length; i++) { var newConstructor = (0, finishers[i])(constructor); if (newConstructor !== undefined) { if (typeof newConstructor !== \"function\") { throw new TypeError(\"Finishers must return a constructor.\"); } constructor = newConstructor; } } return constructor; }, disallowProperty: function disallowProperty(obj, name, objectType) { if (obj[name] !== undefined) { throw new TypeError(objectType + \" can't have a .\" + name + \" property.\"); } } }; return api; }\n\nfunction _createElementDescriptor(def) { var key = _toPropertyKey(def.key); var descriptor; if (def.kind === \"method\") { descriptor = { value: def.value, writable: true, configurable: true, enumerable: false }; } else if (def.kind === \"get\") { descriptor = { get: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"set\") { descriptor = { set: def.value, configurable: true, enumerable: false }; } else if (def.kind === \"field\") { descriptor = { configurable: true, writable: true, enumerable: true }; } var element = { kind: def.kind === \"field\" ? \"field\" : \"method\", key: key, placement: def.static ? \"static\" : def.kind === \"field\" ? \"own\" : \"prototype\", descriptor: descriptor }; if (def.decorators) element.decorators = def.decorators; if (def.kind === \"field\") element.initializer = def.value; return element; }\n\nfunction _coalesceGetterSetter(element, other) { if (element.descriptor.get !== undefined) { other.descriptor.get = element.descriptor.get; } else { other.descriptor.set = element.descriptor.set; } }\n\nfunction _coalesceClassElements(elements) { var newElements = []; var isSameElement = function isSameElement(other) { return other.kind === \"method\" && other.key === element.key && other.placement === element.placement; }; for (var i = 0; i < elements.length; i++) { var element = elements[i]; var other; if (element.kind === \"method\" && (other = newElements.find(isSameElement))) { if (_isDataDescriptor(element.descriptor) || _isDataDescriptor(other.descriptor)) { if (_hasDecorators(element) || _hasDecorators(other)) { throw new ReferenceError(\"Duplicated methods (\" + element.key + \") can't be decorated.\"); } other.descriptor = element.descriptor; } else { if (_hasDecorators(element)) { if (_hasDecorators(other)) { throw new ReferenceError(\"Decorators can't be placed on different accessors with for \" + \"the same property (\" + element.key + \").\"); } other.decorators = element.decorators; } _coalesceGetterSetter(element, other); } } else { newElements.push(element); } } return newElements; }\n\nfunction _hasDecorators(element) { return element.decorators && element.decorators.length; }\n\nfunction _isDataDescriptor(desc) { return desc !== undefined && !(desc.value === undefined && desc.writable === undefined); }\n\nfunction _optionalCallableProperty(obj, name) { var value = obj[name]; if (value !== undefined && typeof value !== \"function\") { throw new TypeError(\"Expected '\" + name + \"' to be a function\"); } return value; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return (0, _typeof2.default)(key) === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if ((0, _typeof2.default)(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if ((0, _typeof2.default)(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction install(_ref) {\n  var use = _ref.use,\n      utils = _ref.utils,\n      registerNodeType = _ref.registerNodeType;\n  var attr = utils.attr;\n\n  var _use = use(_ellipse.default, null, false),\n      Ellipse = _use.Ellipse;\n\n  var reflow = true;\n\n  var CircleAttr = _decorate(null, function (_initialize, _Ellipse$Attr) {\n    var CircleAttr =\n    /*#__PURE__*/\n    function (_Ellipse$Attr2) {\n      (0, _inherits2.default)(CircleAttr, _Ellipse$Attr2);\n\n      function CircleAttr(subject) {\n        var _this;\n\n        (0, _classCallCheck2.default)(this, CircleAttr);\n        _this = (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(CircleAttr).call(this, subject));\n\n        _initialize((0, _assertThisInitialized2.default)(_this));\n\n        _this.setDefault({\n          radius: 10\n        });\n\n        return _this;\n      }\n\n      return CircleAttr;\n    }(_Ellipse$Attr);\n\n    return {\n      F: CircleAttr,\n      d: [{\n        kind: \"set\",\n        decorators: [attr({\n          reflow: reflow\n        })],\n        key: \"radius\",\n        value: function radius(val) {\n          this.set('radius', val);\n        }\n      }]\n    };\n  }, Ellipse.Attr);\n\n  var Circle =\n  /*#__PURE__*/\n  function (_Ellipse) {\n    (0, _inherits2.default)(Circle, _Ellipse);\n\n    function Circle() {\n      (0, _classCallCheck2.default)(this, Circle);\n      return (0, _possibleConstructorReturn2.default)(this, (0, _getPrototypeOf2.default)(Circle).apply(this, arguments));\n    }\n\n    (0, _createClass2.default)(Circle, [{\n      key: \"radiuses\",\n      get: function get() {\n        var radius = this.attr('radius');\n        return [radius, radius];\n      }\n    }]);\n    return Circle;\n  }(Ellipse);\n\n  (0, _defineProperty2.default)(Circle, \"Attr\", CircleAttr);\n  registerNodeType('circle', Circle, false);\n  return {\n    Circle: Circle\n  };\n}","module.exports = {\n  \"_from\": \"@spritejs/shapes@^1.1.5\",\n  \"_id\": \"@spritejs/shapes@1.1.5\",\n  \"_inBundle\": false,\n  \"_integrity\": \"sha512-Ikncs9idy5pZTZgwM3Ej5XCLjP/kssVE4JbILuREIGKRSvUFl58dbHpoKibt0ka79SY2vb5VGnSbtlcdROvszg==\",\n  \"_location\": \"/@spritejs/shapes\",\n  \"_phantomChildren\": {},\n  \"_requested\": {\n    \"type\": \"range\",\n    \"registry\": true,\n    \"raw\": \"@spritejs/shapes@^1.1.5\",\n    \"name\": \"@spritejs/shapes\",\n    \"escapedName\": \"@spritejs%2fshapes\",\n    \"scope\": \"@spritejs\",\n    \"rawSpec\": \"^1.1.5\",\n    \"saveSpec\": null,\n    \"fetchSpec\": \"^1.1.5\"\n  },\n  \"_requiredBy\": [\n    \"/@qcharts/core\"\n  ],\n  \"_resolved\": \"https://registry.npmjs.org/@spritejs/shapes/-/shapes-1.1.5.tgz\",\n  \"_shasum\": \"2ca29810908227bbd020d30de2c9b780f26b1d03\",\n  \"_spec\": \"@spritejs/shapes@^1.1.5\",\n  \"_where\": \"/Users/akirawu/WeChatProjects/miniprogram-test-2/node_modules/@qcharts/core\",\n  \"author\": {\n    \"name\": \"akira-cn\"\n  },\n  \"ava\": {\n    \"files\": [\n      \"**/test/*.test.js\"\n    ],\n    \"require\": [\n      \"@babel/register\"\n    ],\n    \"babel\": {\n      \"testOptions\": {\n        \"babelrc\": true\n      }\n    }\n  },\n  \"bundleDependencies\": false,\n  \"dependencies\": {\n    \"@babel/runtime\": \"^7.2.0\",\n    \"sprite-draggable\": \"0.1.15\",\n    \"svg-path-to-canvas\": \"^1.11.3\"\n  },\n  \"deprecated\": false,\n  \"description\": \"[Test-Online](https://spritejs.github.io/sprite-extend-shapes/docs/website/)\",\n  \"devDependencies\": {\n    \"@babel/cli\": \"^7.2.0\",\n    \"@babel/core\": \"^7.2.0\",\n    \"@babel/plugin-external-helpers\": \"^7.2.0\",\n    \"@babel/plugin-proposal-class-properties\": \"^7.2.1\",\n    \"@babel/plugin-proposal-decorators\": \"^7.2.0\",\n    \"@babel/plugin-transform-runtime\": \"^7.2.0\",\n    \"@babel/preset-env\": \"^7.2.0\",\n    \"@babel/register\": \"^7.0.0\",\n    \"ava\": \"^1.4.1\",\n    \"babel-eslint\": \"^10.0.1\",\n    \"babel-loader\": \"^8.0.5\",\n    \"canvas\": \"^2.0.0-alpha.16\",\n    \"canvas-5-polyfill\": \"^0.1.5\",\n    \"colors\": \"^1.3.1\",\n    \"coveralls\": \"^3.0.2\",\n    \"css-loader\": \"^2.0.0\",\n    \"eslint\": \"^5.0.1\",\n    \"eslint-config-sprite\": \"^1.0.4\",\n    \"eslint-plugin-html\": \"^4.0.5\",\n    \"hamming-distance\": \"^1.0.0\",\n    \"html-webpack-plugin\": \"^3.2.0\",\n    \"imghash\": \"^0.0.3\",\n    \"nyc\": \"^12.0.2\",\n    \"pixelmatch\": \"^4.0.2\",\n    \"rimraf\": \"^2.6.2\",\n    \"spritejs\": \"^2.29.2\",\n    \"style-loader\": \"^0.23.1\",\n    \"webpack\": \"^4.35.0\",\n    \"webpack-bundle-analyzer\": \"^3.0.3\",\n    \"webpack-cli\": \"^3.3.5\",\n    \"webpack-dev-server\": \"^3.7.2\",\n    \"webpack-hot-middleware\": \"^2.24.3\",\n    \"webpack-merge\": \"^4.1.5\"\n  },\n  \"directories\": {\n    \"example\": \"examples\",\n    \"lib\": \"lib\",\n    \"test\": \"test\"\n  },\n  \"license\": \"MIT\",\n  \"main\": \"lib/index.js\",\n  \"module\": \"\",\n  \"name\": \"@spritejs/shapes\",\n  \"nyc\": {\n    \"exclude\": [\n      \"**/test/**/*.js\"\n    ]\n  },\n  \"scripts\": {\n    \"build\": \"npm run build:es6 && npm run build:prod && npm run build:nobrowser\",\n    \"build:es6\": \"babel src -d lib && webpack --env.esnext\",\n    \"build:nobrowser\": \"babel src -d lib && webpack --env.nobrowser\",\n    \"build:prod\": \"babel src -d lib && webpack --env.production\",\n    \"lint\": \"eslint ./ --fix\",\n    \"prepublishOnly\": \"npm run build && node ./script/qcdn\",\n    \"standalone\": \"babel src -d lib && webpack --env.standalone\",\n    \"start\": \"webpack-dev-server --watch-poll\",\n    \"test\": \"nyc ava --serial && rimraf ./coverage && mkdir coverage && nyc report --reporter=html > ./coverage/lcov.info\"\n  },\n  \"version\": \"1.1.5\"\n}\n"]}